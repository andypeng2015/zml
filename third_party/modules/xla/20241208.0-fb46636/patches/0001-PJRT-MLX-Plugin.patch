diff --git a/xla/pjrt/pjrt_client_test.cc b/xla/pjrt/pjrt_client_test.cc
index 64e3552ded..2f2ef61fe0 100644
--- a/xla/pjrt/pjrt_client_test.cc
+++ b/xla/pjrt/pjrt_client_test.cc
@@ -383,7 +383,9 @@ INSTANTIATE_TEST_SUITE_P(
 
 TEST(PjRtClientTest, CopyToDevice) {
   TF_ASSERT_OK_AND_ASSIGN(auto client, GetClient());
-  ASSERT_GT(client->addressable_devices().size(), 1);
+  if (client->addressable_devices().size() < 2) {
+    GTEST_SKIP() << "This test requires at least 2 addressable devices.";
+  }
 
   std::vector<int32_t> data(4, 0);
   Shape shape = ShapeUtil::MakeShape(S32, {4});
@@ -408,7 +410,9 @@ TEST(PjRtClientTest, CopyToDevice) {
 
 TEST(PjRtClientTest, CopyToDeviceAsync) {
   TF_ASSERT_OK_AND_ASSIGN(auto client, GetClient());
-  ASSERT_GT(client->addressable_devices().size(), 1);
+  if (client->addressable_devices().size() < 2) {
+    GTEST_SKIP() << "This test requires at least 2 addressable devices.";
+  }
 
   std::vector<int32_t> data(4, 0);
   Shape shape = ShapeUtil::MakeShape(S32, {4});
@@ -447,7 +451,9 @@ TEST(PjRtClientTest, CopyToDeviceAsync) {
 
 TEST(PjRtClientTest, CopyToDeviceAsyncExternalCpuOnly) {
   TF_ASSERT_OK_AND_ASSIGN(auto client, GetClient());
-  ASSERT_GT(client->addressable_devices().size(), 1);
+  if (client->addressable_devices().size() < 2) {
+    GTEST_SKIP() << "This test requires at least 2 addressable devices.";
+  }
 
   // Skip non-CPU platforms.
   if (client->platform_id() != CpuId()) {
@@ -493,7 +499,9 @@ TEST(PjRtClientTest, CopyToDeviceAsyncExternalCpuOnly) {
 
 TEST(PjRtClientTest, CreateViewOfUnalignedBufferReturnsErrorCpuOnly) {
   TF_ASSERT_OK_AND_ASSIGN(auto client, GetClient());
-  ASSERT_GT(client->addressable_devices().size(), 1);
+  if (client->addressable_devices().size() < 2) {
+    GTEST_SKIP() << "This test requires at least 2 addressable devices.";
+  }
 
   // Skip non-CPU platforms.
   if (client->platform_id() != CpuId()) {
diff --git a/xla/pjrt/plugin/mlx/BUILD b/xla/pjrt/plugin/mlx/BUILD
new file mode 100644
index 0000000000..5db074175c
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/BUILD
@@ -0,0 +1,170 @@
+load("//xla:xla.bzl", "xla_cc_binary", "xla_cc_test")
+
+package(
+    # copybara:uncomment default_applicable_licenses = ["//tensorflow:license"],
+    default_visibility = ["//visibility:public"],
+    licenses = ["notice"],
+)
+
+cc_library(
+    name = "buffer",
+    srcs = ["buffer.cc"],
+    hdrs = ["buffer.h"],
+    deps = [
+        ":logging",
+        "//xla:literal",
+        "//xla:shape_util",
+        "//xla:util",
+        "//xla/hlo/translate/hlo_to_mhlo:hlo_utils",
+        "//xla/hlo/translate/mhlo_to_hlo:literal_exporter",
+        "//xla/hlo/translate/mhlo_to_hlo:type_to_shape",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_compiler",
+        "//xla/pjrt:pjrt_future",
+        "@com_google_absl//absl/functional:any_invocable",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/status:statusor",
+        "@llvm-project//llvm:Support",
+        "@llvm-project//mlir:AsmParser",
+        "@llvm-project//mlir:IR",
+        "@llvm-project//mlir:Support",
+    ],
+)
+
+cc_library(
+    name = "executable",
+    srcs = ["executable.cc"],
+    hdrs = ["executable.h"],
+    deps = [
+        "@libmlx",
+        ":buffer",
+        ":logging",
+        "//xla/hlo/builder:xla_computation",
+        "//xla/hlo/translate:stablehlo",
+        "//xla/mlir/utils:error_util",
+        "//xla/mlir_hlo:mhlo_passes",
+        "//xla/mlir_hlo:stablehlo_extension_passes",
+        "//xla/pjrt:mlir_to_hlo",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_executable",
+        "//xla/pjrt:pjrt_future",
+        "//xla/service:computation_placer_hdr",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@llvm-project//llvm:Support",
+        "@llvm-project//mlir:AsmParser",
+        "@llvm-project//mlir:BytecodeWriter",
+        "@llvm-project//mlir:DataLayoutInterfaces",
+        "@llvm-project//mlir:FuncDialect",
+        "@llvm-project//mlir:IR",
+        "@llvm-project//mlir:Parser",
+        "@llvm-project//mlir:Pass",
+        "@llvm-project//mlir:Support",
+        "@llvm-project//mlir:Transforms",
+        "@stablehlo//:reference_api",
+        "@stablehlo//:stablehlo_passes",
+        "@tsl//tsl/platform:statusor",
+    ],
+)
+
+cc_library(
+    name = "device",
+    srcs = ["device.cc"],
+    hdrs = ["device.h"],
+    deps = [
+        ":logging",
+        "//xla:util",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_common",
+        "//xla/pjrt:pjrt_compiler",
+        "//xla/pjrt:pjrt_device_description",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings:str_format",
+        "@com_google_absl//absl/strings:string_view",
+        "@com_google_absl//absl/types:span",
+    ],
+)
+
+cc_library(
+    name = "client_cpp_pjrt",
+    srcs = [
+        "client_cpp_pjrt.cc",
+    ],
+    hdrs = [
+        "client_cpp_pjrt.h",
+    ],
+    deps = [
+        ":buffer",
+        ":device",
+        ":executable",
+        ":logging",
+        "//xla:literal",
+        "//xla:shape_util",
+        "//xla:util",
+        "//xla/pjrt:host_memory_spaces",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_common",
+        "//xla/pjrt:pjrt_compiler",
+        "//xla/tsl/framework:allocator",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings:str_format",
+        "@com_google_absl//absl/strings:string_view",
+        "@com_google_absl//absl/types:span",
+        "@tsl//tsl/platform:fingerprint",
+    ],
+)
+
+cc_library(
+    name = "client_c_pjrt",
+    srcs = [
+        "client_c_pjrt.cc",
+    ],
+    hdrs = ["client_c_pjrt.h"],
+    deps = [
+        ":client_cpp_pjrt",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt/c:pjrt_c_api_hdrs",
+        "//xla/pjrt/c:pjrt_c_api_layouts_extension_hdrs",
+        "//xla/pjrt/c:pjrt_c_api_wrapper_impl",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/strings:string_view",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "logging",
+    srcs = ["logging.cc"],
+    hdrs = ["logging.h"],
+    deps = [
+        "@com_google_absl//absl/base:log_severity",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:globals",
+        "@llvm-project//llvm:Support",
+        "@llvm-project//mlir:AsmParser",
+        "@llvm-project//mlir:DataLayoutInterfaces",
+        "@llvm-project//mlir:IR",
+    ],
+)
+
+xla_cc_test(
+    name = "plugin_pjrt_test",
+    srcs = ["plugin_pjrt_test.cc"],
+    deps = [
+        ":client_c_pjrt",
+        ":client_cpp_pjrt",
+        "//xla/pjrt:pjrt_client_test_common",
+        "//xla/pjrt/c:pjrt_c_api_test_common",
+        "//xla/pjrt/c:pjrt_c_api_wrapper_impl",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+xla_cc_binary(
+    name = "stablehlo_reference_plugin.so",
+    linkshared = True,
+    deps = [
+        ":client_c_pjrt",
+    ],
+)
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/buffer.cc b/xla/pjrt/plugin/mlx/buffer.cc
new file mode 100644
index 0000000000..619cae1e5f
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/buffer.cc
@@ -0,0 +1,331 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/plugin/mlx/buffer.h"
+
+ #include <cstdint>
+ #include <memory>
+ #include <string>
+ #include <utility>
+ #include <vector>
+
+ #include "absl/functional/any_invocable.h"
+ #include "absl/log/log.h"
+ #include "absl/status/statusor.h"
+ #include "llvm/Support/Casting.h"
+ #include "llvm/Support/raw_ostream.h"
+ #include "mlir/AsmParser/AsmParser.h"
+ #include "mlir/IR/Attributes.h"
+ #include "mlir/IR/Builders.h"
+ #include "mlir/IR/BuiltinAttributes.h"
+ #include "mlir/IR/BuiltinTypeInterfaces.h"
+ #include "mlir/IR/MLIRContext.h"
+ #include "mlir/Support/DebugStringHelper.h"
+ #include "xla/hlo/translate/hlo_to_mhlo/hlo_utils.h"
+ #include "xla/hlo/translate/mhlo_to_hlo/literal_exporter.h"
+ #include "xla/hlo/translate/mhlo_to_hlo/type_to_shape.h"
+ #include "xla/literal.h"
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/pjrt_compiler.h"
+ #include "xla/pjrt/pjrt_future.h"
+ #include "xla/pjrt/plugin/mlx/logging.h"
+ #include "xla/shape.h"
+ #include "xla/util.h"
+
+ namespace mlir::stablehlo {
+
+ using xla::MutableLiteralBase;
+ using xla::PjRtBuffer;
+ using xla::PjRtClient;
+ using xla::PjRtDevice;
+ using xla::PjRtFuture;
+ using xla::PjRtMemorySpace;
+ using xla::PjRtPlatformId;
+ using xla::Shape;
+
+ #define UNIMPLEMENTED(name) \
+   xla::Unimplemented("MlirPjrtBuffer::" #name " is not implemented")
+
+ class MlirPjrtBuffer : public PjRtBuffer {
+  public:
+   MlirPjrtBuffer(const Shape& shape, PjRtMemorySpace* memory_space)
+       : xla::PjRtBuffer(),
+         context_(),
+         buffer_(),
+         shape_(shape),
+         memory_space_(memory_space) {
+     TRACE_ME_MEMBER;
+   }
+
+   class MlirClonedExternalReference : public ExternalReference {
+    public:
+     explicit MlirClonedExternalReference(PjRtBuffer* buffer,
+                                          PjRtMemorySpace* memory_space)
+         : buffer_() {
+       TRACE_ME_MEMBER;
+       auto mlir_buffer = GetAttributeFromBuffer(buffer);
+       if (!mlir_buffer.ok()) {
+         LOG(ERROR) << "Could not get attribute from buffer: "
+                    << mlir_buffer.status();
+       }
+       buffer_ =
+           CreateMlirBufferFromAttribute(mlir_buffer.value(), memory_space);
+       data_ptr_ = (void*)mlir_buffer.value().getRawData().data();
+     }
+
+    private:
+     std::unique_ptr<PjRtBuffer> buffer_;
+   };
+
+   // All buffers are managed by the MLIR Context
+   ~MlirPjrtBuffer() override = default;
+
+   MlirPjrtBuffer(const MlirPjrtBuffer&) = delete;
+   MlirPjrtBuffer(MlirPjrtBuffer&&) = delete;
+   MlirPjrtBuffer& operator=(const MlirPjrtBuffer&) = delete;
+   MlirPjrtBuffer& operator=(MlirPjrtBuffer&&) = delete;
+
+   static std::unique_ptr<MlirPjrtBuffer> CreateFromLiteral(
+       const xla::LiteralSlice& literal, xla::PjRtMemorySpace* memory_space) {
+     TRACE_ME;
+     LOG(INFO) << "CreateFromLiteral: " << literal.ToString() << "\n";
+     auto buffer =
+         std::make_unique<MlirPjrtBuffer>(literal.shape(), memory_space);
+     LOG(INFO) << "CreateFromLiteral -> " << (void*)buffer.get() << "\n";
+     mlir::Builder builder(&buffer->context_);
+     auto attr = xla::CreateDenseElementsAttrFromLiteral(literal, builder);
+     if (!attr.ok()) {
+       LOG(ERROR) << "Could not create dense elements attr from literal: "
+                  << attr.status();
+       return nullptr;
+     }
+     buffer->buffer_ = attr.value();
+     return buffer;
+   }
+
+   static std::unique_ptr<MlirPjrtBuffer> CreateFromAttribute(
+       DenseElementsAttr attr, xla::PjRtMemorySpace* memory_space) {
+     TRACE_ME;
+
+     // MLIR type to xla shape:
+     Shape shape = xla::TypeToShape(attr.getType());
+     auto buffer = std::make_unique<MlirPjrtBuffer>(shape, memory_space);
+     buffer->buffer_ = CloneIntoContext(attr, buffer->context_);
+     LOG(INFO) << "CreateFromAttribute(" << ToString(attr) << ") -> "
+               << (void*)buffer.get() << "\n";
+     return buffer;
+   }
+
+   const Shape& on_device_shape() const override {
+     TRACE_ME_MEMBER;
+     return shape_;
+   }
+   absl::StatusOr<Shape> logical_on_device_shape() override {
+     TRACE_ME_MEMBER;
+     return shape_;
+   }
+
+   PjRtPlatformId platform_id() const {
+     TRACE_ME_MEMBER;
+     return client()->platform_id();
+   }
+   absl::string_view platform_name() const {
+     TRACE_ME_MEMBER;
+     return client()->platform_name();
+   }
+
+   bool IsEmptyTuple() const {
+     TRACE_ME_MEMBER;
+     return shape_.IsTuple() && shape_.tuple_shapes().empty();
+   }
+
+   // Buffer knows device + client per older design, should only need
+   // memory_space.
+   PjRtMemorySpace* memory_space() const override {
+     TRACE_ME_MEMBER;
+     return memory_space_;
+   }
+   PjRtDevice* device() const override {
+     TRACE_ME_MEMBER;
+     return memory_space_->devices().front();
+   }
+   PjRtClient* client() const override {
+     TRACE_ME_MEMBER;
+     return memory_space_->client();
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer::ExternalReference>>
+   AcquireExternalReference() override {
+     TRACE_ME_MEMBER;
+     return std::make_unique<MlirClonedExternalReference>(this, memory_space_);
+   }
+
+   xla::PjRtFuture<> ToLiteral(xla::MutableLiteralBase* literal) override {
+     TRACE_ME_MEMBER;
+     if (IsEmptyTuple()) {
+       return PjRtFuture<>(
+           xla::InvalidArgument("ToLiteral called on empty tuple"));
+     }
+
+     absl::StatusOr<xla::Literal> to_copy =
+         mhlo::CreateLiteralFromAttribute(buffer_, {});
+     if (!to_copy.ok()) return PjRtFuture<>(to_copy.status());
+
+     // Synchronous! To make async, make the buffer, start the copy, and return a
+     // future that is ready when the copy is done.
+     auto status = literal->CopyFrom(to_copy.value());
+     if (!status.ok()) return PjRtFuture<>(status);
+     return PjRtFuture<>(absl::OkStatus());
+   }
+
+   PjRtFuture<> LazyToLiteral(
+       absl::AnyInvocable<absl::StatusOr<MutableLiteralBase*>() &&> generator)
+       override {
+     TRACE_ME_MEMBER;
+     auto buffer = std::move(generator)();
+     if (!buffer.ok()) return PjRtFuture<>(buffer.status());
+     return ToLiteral(buffer.value());
+   }
+
+   absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override {
+     // This is needed by AcquireExternalReference, for framework figuring out
+     // how to read the underlying buffer data.
+     TRACE_ME_MEMBER;
+     if (!buffer_) return 0;
+     return buffer_.getRawData().size();
+   }
+
+   PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,
+                              int64_t transfer_size) override {
+     TRACE_ME_MEMBER;
+     return PjRtFuture<>(UNIMPLEMENTED(CopyRawToHost));
+   }
+
+   absl::StatusOr<std::unique_ptr<ExternalReference>>
+   ReleaseDeviceMemoryOwnership(bool wait_for_operations_to_complete) override {
+     TRACE_ME_MEMBER;
+     auto external_ref = AcquireExternalReference();
+     Delete();
+     return external_ref;
+   }
+
+   // Remove the buffer if deleted.
+   // Note: deleted and uninitialized appear the same in this scenario.
+   // Consider changing to mlir::NoneType when deleted.
+   void Delete() override {
+     TRACE_ME_MEMBER;
+     buffer_ = {};
+   }
+
+   bool IsDeleted() override {
+     TRACE_ME_MEMBER;
+     return !buffer_;
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CopyToDevice(
+       xla::PjRtDevice* dst_device) override {
+     TRACE_ME_MEMBER;
+     return CopyToMemorySpace(
+         dst_device->default_memory_space().value_or(nullptr));
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CopyToMemorySpace(
+       xla::PjRtMemorySpace* dst_memory_space) override {
+     TRACE_ME_MEMBER;
+     return CreateMlirBufferFromAttribute(buffer_, dst_memory_space);
+   }
+
+   void CopyToRemoteDevice(
+       xla::PjRtFuture<std::string> serialized_descriptor,
+       xla::PjRtBuffer::RemoteSendCallback on_done) override {
+     TRACE_ME_MEMBER;
+     on_done(UNIMPLEMENTED(CopyToRemoteDevice), false);
+   }
+
+   void CopyToRemoteDeviceScattered(
+       xla::PjRtFuture<std::vector<std::string>> serialized_descriptors,
+       std::vector<RemoteSendCallback> callbacks,
+       const xla::PjRtBuffer::ScatterDetails& scatter_details) override {
+     TRACE_ME_MEMBER;
+     for (auto cb : callbacks) {
+       cb(UNIMPLEMENTED(CopyToRemoteDeviceScattered), false);
+     }
+   }
+
+   xla::PjRtFuture<> GetReadyFuture() override {
+     TRACE_ME_MEMBER;
+     LOG(INFO) << "GetReadyFuture(" << (void*)this << ")\n";
+     // Synchronous! To make async, have the device make a buffer with a ready
+     // future that is ready when the computation is done / buffer is ready.
+     return PjRtFuture<>(absl::OkStatus());
+   }
+
+   bool IsOnCpu() const override {
+     // If buffer is on CPU, it will be shared with framework via
+     // GetExternalReference, lse it is copied back to host.
+     // Since we are using reference interpreter, we are running on CPU in a
+     // shared memory space.
+     TRACE_ME_MEMBER;
+     return false;
+   }
+
+   mlir::DenseElementsAttr GetBufferAttribute() const { return buffer_; }
+
+  private:
+   MLIRContext context_;
+   mlir::DenseElementsAttr buffer_;
+
+   xla::Shape shape_;
+   PjRtMemorySpace* memory_space_;
+ };
+
+ std::unique_ptr<PjRtBuffer> CreateMlirBufferFromLiteral(
+     const xla::LiteralSlice& literal, xla::PjRtMemorySpace* memory_space) {
+   TRACE_ME;
+   return MlirPjrtBuffer::CreateFromLiteral(literal, memory_space);
+ }
+
+ std::unique_ptr<PjRtBuffer> CreateMlirBufferFromAttribute(
+     DenseElementsAttr attr, xla::PjRtMemorySpace* memory_space) {
+   TRACE_ME;
+   return MlirPjrtBuffer::CreateFromAttribute(attr, memory_space);
+ }
+
+ std::unique_ptr<PjRtBuffer> CreateMlirBufferUninitizlied(
+     const Shape& shape, PjRtMemorySpace* memory_space) {
+   TRACE_ME;
+   return std::make_unique<MlirPjrtBuffer>(shape, memory_space);
+ }
+
+ absl::StatusOr<mlir::DenseElementsAttr> GetAttributeFromBuffer(
+     xla::PjRtBuffer* buffer) {
+   TRACE_ME;
+   if (buffer == nullptr || buffer->IsDeleted()) {
+     return xla::InvalidArgument("Buffer is null or deleted");
+   }
+   auto mlir_buffer = dynamic_cast<MlirPjrtBuffer*>(buffer);
+   if (mlir_buffer == nullptr) {
+     return xla::InvalidArgument("Buffer is not a MlirPjrtBuffer");
+   }
+   LOG(INFO) << "GetAttributeFromBuffer(" << (void*)buffer << ") -> "
+             << ToString(mlir_buffer->GetBufferAttribute()) << "\n";
+   return mlir_buffer->GetBufferAttribute();
+ }
+
+ DenseElementsAttr CloneIntoContext(DenseElementsAttr attr,
+                                    MLIRContext& context) {
+   Type type = mlir::parseType(mlir::debugString(attr.getType()), &context);
+   return DenseElementsAttr::getFromRawBuffer(llvm::cast<ShapedType>(type),
+                                              attr.getRawData());
+ }
+
+ }  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/buffer.h b/xla/pjrt/plugin/mlx/buffer.h
new file mode 100644
index 0000000000..8cb815fe6d
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/buffer.h
@@ -0,0 +1,37 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_BUFFER_H_
+ #define XLA_PJRT_PLUGIN_STABLEHLO_MLX_BUFFER_H_
+
+ #include <memory>
+
+ #include "mlir/IR/BuiltinAttributes.h"
+ #include "xla/literal.h"
+ #include "xla/pjrt/pjrt_client.h"
+
+ namespace mlir::stablehlo {
+
+ std::unique_ptr<xla::PjRtBuffer> CreateMlirBufferFromLiteral(
+     const xla::LiteralSlice& literal, xla::PjRtMemorySpace* memory_space);
+ std::unique_ptr<xla::PjRtBuffer> CreateMlirBufferFromAttribute(
+     DenseElementsAttr attribute, xla::PjRtMemorySpace* memory_space);
+ std::unique_ptr<xla::PjRtBuffer> CreateMlirBufferUninitizlied(
+     const xla::Shape& shape, xla::PjRtMemorySpace* memory_space);
+ absl::StatusOr<DenseElementsAttr> GetAttributeFromBuffer(
+     xla::PjRtBuffer* buffer);
+ DenseElementsAttr CloneIntoContext(DenseElementsAttr attr,
+                                    MLIRContext& context);
+
+ }  // namespace mlir::stablehlo
+
+ #endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_BUFFER_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_c_pjrt.cc b/xla/pjrt/plugin/mlx/client_c_pjrt.cc
new file mode 100644
index 0000000000..e323309613
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_c_pjrt.cc
@@ -0,0 +1,73 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/plugin/mlx/client_c_pjrt.h"
+
+ #include <cstdio>
+ #include <memory>
+ #include <utility>
+
+ #include "absl/status/status.h"
+ #include "absl/strings/string_view.h"
+ #include "xla/pjrt/c/pjrt_c_api.h"
+ #include "xla/pjrt/c/pjrt_c_api_layouts_extension.h"
+ #include "xla/pjrt/c/pjrt_c_api_wrapper_impl.h"
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/plugin/mlx/client_cpp_pjrt.h"
+
+ namespace mlir::stablehlo {
+
+ using xla::PjRtClient;
+
+ std::unique_ptr<PjRtClient> GetPluginPjRtClient() {
+   return CreateStablehloMlxPjrtClient();
+ }
+
+ // Create my client
+ PJRT_Error* PJRT_StablehloMlxClient_Create(
+     PJRT_Client_Create_Args* args) {
+   std::unique_ptr<PjRtClient> client = GetPluginPjRtClient();
+   args->client = pjrt::CreateWrapperClient(std::move(client));
+   printf("Creating PJRT Client from client\n");
+   return nullptr;
+ }
+
+ PJRT_Error* PJRT_StablehloMlxExecuteContext_Create(
+     PJRT_ExecuteContext_Create_Args* args) {
+   return new PJRT_Error{absl::UnimplementedError(
+       "ExecuteContext not supported for client execution.")};
+ }
+
+ PJRT_Error* PJRT_StablehloMlxDeviceTopology_Create(
+     PJRT_TopologyDescription_Create_Args* args) {
+   return new PJRT_Error{absl::UnimplementedError(
+       "Topology not supported for client compilation.")};
+ }
+
+ }  // namespace mlir::stablehlo
+
+ const PJRT_Api* GetPjrtApi() {
+   printf("C++ Calling GetPjrtApi");
+   static PJRT_Layouts_Extension layouts_extension =
+       pjrt::CreateLayoutsExtension(nullptr);
+
+   static const PJRT_Api pjrt_api = pjrt::CreatePjrtApi(
+       mlir::stablehlo::PJRT_StablehloMlxClient_Create,
+       mlir::stablehlo::PJRT_StablehloMlxExecuteContext_Create,
+       mlir::stablehlo::PJRT_StablehloMlxDeviceTopology_Create,
+       pjrt::PJRT_Plugin_Initialize_NoOp,
+       reinterpret_cast<PJRT_Extension_Base*>(&layouts_extension),
+       pjrt::PJRT_Plugin_Attributes_Xla);
+
+   printf("stablehlo_mlx client called GetPjrtApi\n");
+   return &pjrt_api;
+ }
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_c_pjrt.h b/xla/pjrt/plugin/mlx/client_c_pjrt.h
new file mode 100644
index 0000000000..fb768e8905
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_c_pjrt.h
@@ -0,0 +1,24 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_C_PJRT_H_
+ #define XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_C_PJRT_H_
+
+ #include "xla/pjrt/c/pjrt_c_api.h"
+
+ extern "C" {
+
+ // Does not pass ownership of returned PJRT_Api* to caller.
+ const PJRT_Api* GetPjrtApi();
+ }
+
+ #endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_C_PJRT_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_cpp_pjrt.cc b/xla/pjrt/plugin/mlx/client_cpp_pjrt.cc
new file mode 100644
index 0000000000..ff59cf09dc
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_cpp_pjrt.cc
@@ -0,0 +1,294 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/plugin/mlx/client_cpp_pjrt.h"
+
+ #include <cstddef>
+ #include <cstdint>
+ #include <cstdlib>
+ #include <memory>
+ #include <vector>
+
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/types/span.h"
+ #include "xla/literal.h"
+ #include "xla/pjrt/host_memory_spaces.h"
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/pjrt_common.h"
+ #include "xla/pjrt/pjrt_compiler.h"
+ #include "xla/pjrt/plugin/mlx/buffer.h"
+ #include "xla/pjrt/plugin/mlx/device.h"
+ #include "xla/pjrt/plugin/mlx/executable.h"
+ #include "xla/pjrt/plugin/mlx/logging.h"
+ #include "xla/shape_util.h"
+ #include "xla/util.h"
+ #include "tsl/platform/fingerprint.h"
+
+ #define UNIMPLEMENTED(name) \
+   xla::Unimplemented("MlirPjrtBuffer::" #name " is not implemented")
+
+ namespace mlir::stablehlo {
+
+ const xla::PjRtPlatformId kStablehloMlxBackendId =
+     tsl::Fingerprint64(kStablehloMlxBackendName);
+
+ class StablehloMlxPjrtClient : public xla::PjRtClient {
+  public:
+   StablehloMlxPjrtClient()
+       : xla::PjRtClient(),
+         owned_devices_(),
+         devices_(),
+         owned_memory_space_(),
+         memory_space_(nullptr) {
+     // Init device and memory space.
+     TRACE_ME_MEMBER;
+     owned_devices_.push_back(GetStablehloMlxDevice(this));
+     devices_.push_back(owned_devices_.back().get());
+     owned_memory_space_ = std::make_unique<xla::UnpinnedHostMemorySpace>(
+         /*id=*/0, devices_.front());
+     memory_space_ = owned_memory_space_.get();
+     AttachStablehloMlxMemorySpace(devices_.front(), memory_space_);
+   }
+
+   ~StablehloMlxPjrtClient() override {};
+
+   absl::string_view platform_name() const override {
+     TRACE_ME_MEMBER;
+     return kStablehloMlxBackendName;
+   }
+   int process_index() const override {
+     TRACE_ME_MEMBER;
+     return 0;
+   }
+
+   int device_count() const override {
+     TRACE_ME_MEMBER;
+     return devices_.size();
+   }
+
+   int addressable_device_count() const override {
+     TRACE_ME_MEMBER;
+     return devices_.size();
+   }
+
+   absl::Span<xla::PjRtDevice* const> devices() const override {
+     TRACE_ME_MEMBER;
+     return devices_;
+   }
+   absl::Span<xla::PjRtDevice* const> addressable_devices() const override {
+     TRACE_ME_MEMBER;
+     return devices_;
+   }
+
+   absl::Span<xla::PjRtMemorySpace* const> memory_spaces() const override {
+     TRACE_ME_MEMBER;
+     return absl::MakeSpan(&memory_space_, 1);
+   }
+
+   // Return an ID that identifies the platform via tsl fingerprint.
+   xla::PjRtPlatformId platform_id() const override {
+     TRACE_ME_MEMBER;
+     return kStablehloMlxBackendId;
+   }
+
+   // Returns a string containing human-readable, platform-specific version
+   // info (e.g. the CUDA version on GPU or libtpu version on Cloud TPU).
+   absl::string_view platform_version() const override {
+     TRACE_ME_MEMBER;
+     return "StableHLO MLX v0.1";
+   }
+
+   /////////////
+   // Device
+   /////////////
+
+   // Lookup any PjRtDevice for a given PjRtDevice::id().
+   // TODO: Should this be a base class? I.e. why doesn't the base client have
+   // a vector a device pointers?
+   absl::StatusOr<xla::PjRtDevice*> LookupDevice(
+       xla::PjRtGlobalDeviceId global_device_id) const override {
+     TRACE_ME_MEMBER;
+     for (auto device : devices_) {
+       if (device->global_device_id() == global_device_id) {
+         return device;
+       }
+     }
+     // TODO: This error should be a base class method since its used in tests.
+     return xla::InvalidArgument("No matching device found for device_id %d",
+                                 global_device_id.value());
+   }
+
+   absl::StatusOr<xla::PjRtDevice*> LookupAddressableDevice(
+       xla::PjRtLocalDeviceId local_device_id) const override {
+     TRACE_ME_MEMBER;
+
+     for (auto* device : addressable_devices()) {
+       if (local_device_id == device->local_device_id()) {
+         return device;
+       }
+     }
+     return xla::InvalidArgument(
+         "No matching device found for local_device_id %d",
+         local_device_id.value());
+   }
+
+   absl::StatusOr<xla::DeviceAssignment> GetDefaultDeviceAssignment(
+       int num_replicas, int num_partitions) const override {
+     TRACE_ME_MEMBER;
+     xla::DeviceAssignment assignment(num_replicas, num_partitions);
+     for (int64_t i = 0; i < num_replicas; ++i) {
+       for (int64_t j = 0; j < num_partitions; ++j) {
+         auto idx = (i + (j * num_replicas)) % devices_.size();
+         assignment(i, j) = devices_[idx]->global_device_id().value();
+       }
+     }
+     return assignment;
+   }
+
+   /////////////////
+   // Buffer methods
+   /////////////////
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CreateErrorBuffer(
+       absl::Status error, const xla::Shape& shape,
+       xla::PjRtDevice* device) override {
+     // Prefer memory space implementation, device holding buffer is
+     // deprecated.
+     return CreateErrorBuffer(error, shape,
+                              device->default_memory_space().value_or(nullptr));
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CreateErrorBuffer(
+       absl::Status error, const xla::Shape& shape,
+       xla::PjRtMemorySpace* memory) override {
+     return UNIMPLEMENTED(CreateErrorBuffer);
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CreateUninitializedBuffer(
+       const xla::Shape& shape, xla::PjRtDevice* device) override {
+     TRACE_ME_MEMBER;
+     return CreateMlirBufferUninitizlied(
+         shape, device->default_memory_space().value_or(nullptr));
+   }
+
+   absl::StatusOr<std::unique_ptr<PjRtClient::AsyncHostToDeviceTransferManager>>
+   CreateBuffersForAsyncHostToDevice(absl::Span<const xla::Shape> shapes,
+                                     xla::PjRtDevice* device) override {
+     TRACE_ME_MEMBER;
+     return CreateBuffersForAsyncHostToDevice(
+         shapes, device->default_memory_space().value_or(nullptr));
+   }
+
+   absl::StatusOr<std::unique_ptr<PjRtClient::AsyncHostToDeviceTransferManager>>
+   CreateBuffersForAsyncHostToDevice(
+       absl::Span<const xla::Shape> shapes,
+       xla::PjRtMemorySpace* memory_space) override {
+     TRACE_ME_MEMBER;
+     return UNIMPLEMENTED(CreateBuffersForAsyncHostToDevice);
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostBuffer(
+       const void* data, xla::PrimitiveType type, absl::Span<int64_t const> dims,
+       std::optional<absl::Span<int64_t const>> byte_strides,
+       HostBufferSemantics host_buffer_semantics,
+       absl::AnyInvocable<void() &&> on_done_with_host_buffer,
+       xla::PjRtDevice* device) override {
+     TRACE_ME_MEMBER;
+     return BufferFromHostBuffer(
+         data, type, dims, byte_strides, host_buffer_semantics,
+         std::move(on_done_with_host_buffer),
+         device->default_memory_space().value_or(nullptr), nullptr);
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostBuffer(
+       const void* data, xla::PrimitiveType type, absl::Span<int64_t const> dims,
+       std::optional<absl::Span<int64_t const>> byte_strides,
+       HostBufferSemantics host_buffer_semantics,
+       absl::AnyInvocable<void() &&> on_done_with_host_buffer,
+       xla::PjRtDevice* device, const xla::Layout* device_layout) override {
+     TRACE_ME_MEMBER;
+     return BufferFromHostBuffer(
+         data, type, dims, byte_strides, host_buffer_semantics,
+         std::move(on_done_with_host_buffer),
+         device->default_memory_space().value_or(nullptr), device_layout);
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostBuffer(
+       const void* data, xla::PrimitiveType type, absl::Span<int64_t const> dims,
+       std::optional<absl::Span<int64_t const>> byte_strides,
+       HostBufferSemantics host_buffer_semantics,
+       absl::AnyInvocable<void() &&> on_done_with_host_buffer,
+       xla::PjRtMemorySpace* memory_space,
+       const xla::Layout* device_layout) override {
+     TRACE_ME_MEMBER;
+     // Buffer to Literal
+     auto shape = xla::ShapeUtil::MakeShape(type, dims);
+     auto literal =
+         xla::BorrowingLiteral(reinterpret_cast<const char*>(data), shape);
+     auto buffer = CreateMlirBufferFromLiteral(literal, memory_space);
+     if (on_done_with_host_buffer) {
+       // If host is awaiting the result, must call this function.
+       std::move(on_done_with_host_buffer)();
+       on_done_with_host_buffer = nullptr;
+     }
+     return buffer;
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostLiteral(
+       const xla::LiteralSlice& literal, xla::PjRtDevice* device) override {
+     TRACE_ME_MEMBER;
+     return CreateMlirBufferFromLiteral(
+         literal, device->default_memory_space().value_or(nullptr));
+   }
+
+   absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostLiteral(
+       const xla::LiteralSlice& literal,
+       xla::PjRtMemorySpace* memory_space) override {
+     TRACE_ME_MEMBER;
+     return CreateMlirBufferFromLiteral(literal, memory_space);
+   }
+
+   ///////////
+   // Compile
+   ///////////
+   absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> Compile(
+       mlir::ModuleOp module, xla::CompileOptions options) override {
+     TRACE_ME_MEMBER;
+     return mlir::stablehlo::StablehloMlxCompile(
+         module, GetDefaultDeviceAssignment(1, devices_.size()).value(), this);
+   }
+
+   // Compile `computation` with given `options`.
+   absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> Compile(
+       const xla::XlaComputation& computation,
+       xla::CompileOptions options) override {
+     TRACE_ME_MEMBER;
+     return mlir::stablehlo::StablehloMlxCompile(
+         computation.proto(),
+         GetDefaultDeviceAssignment(1, devices_.size()).value(), this);
+   }
+
+  private:
+   std::vector<std::unique_ptr<xla::PjRtDevice>> owned_devices_;
+   std::vector<xla::PjRtDevice*> devices_;
+   std::unique_ptr<xla::PjRtMemorySpace> owned_memory_space_;
+   xla::PjRtMemorySpace* memory_space_;
+ };  // end class
+
+ std::unique_ptr<xla::PjRtClient> CreateStablehloMlxPjrtClient() {
+   SetupLogLevelFromEnv();
+   return std::make_unique<StablehloMlxPjrtClient>();
+ }
+
+ }  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_cpp_pjrt.h b/xla/pjrt/plugin/mlx/client_cpp_pjrt.h
new file mode 100644
index 0000000000..5481539651
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_cpp_pjrt.h
@@ -0,0 +1,30 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_CPP_PJRT_H_
+ #define XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_CPP_PJRT_H_
+
+ #include <memory>
+
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/pjrt_compiler.h"
+
+ namespace mlir::stablehlo {
+
+ inline constexpr char kStablehloMlxBackendName[] = "stablehlo_mlx";
+ extern const xla::PjRtPlatformId kStablehloMlxBackendId;
+
+ std::unique_ptr<xla::PjRtClient> CreateStablehloMlxPjrtClient();
+
+ }  // namespace mlir::stablehlo
+
+ #endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_CPP_PJRT_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/device.cc b/xla/pjrt/plugin/mlx/device.cc
new file mode 100644
index 0000000000..3583a87234
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/device.cc
@@ -0,0 +1,205 @@
+/* Copyright 2024 The OpenXLA Authors.
+
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/plugin/mlx/device.h"
+
+ #include "absl/status/statusor.h"
+ #include "absl/strings/str_format.h"
+ #include "absl/strings/string_view.h"
+ #include "absl/types/span.h"
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/pjrt_common.h"
+ #include "xla/pjrt/pjrt_compiler.h"
+ #include "xla/pjrt/pjrt_device_description.h"
+ #include "xla/pjrt/plugin/mlx/logging.h"
+ #include "xla/util.h"
+
+ #define UNIMPLEMENTED(name) \
+   xla::Unimplemented("StablehloMlxDevice::" #name " is not implemented")
+
+ namespace mlir::stablehlo {
+
+ using xla::LiteralSlice;
+ using xla::MutableBorrowingLiteral;
+ using xla::PjRtClient;
+ using xla::PjRtDevice;
+ using xla::PjRtDeviceAttribute;
+ using xla::PjRtDeviceDescription;
+ using xla::PjRtGlobalDeviceId;
+ using xla::PjRtLocalDeviceId;
+ using xla::PjRtLocalHardwareId;
+ using xla::PjRtMemorySpace;
+ using xla::ScopedAsyncTrackingEvent;
+ using xla::Unimplemented;
+
+ // Devices need a device description.
+ class StablehloMlxDeviceDescription final : public PjRtDeviceDescription {
+  public:
+   explicit StablehloMlxDeviceDescription(int process_id,
+                                                int local_device_id)
+       : id_(local_device_id),
+         process_index_(process_id),
+         local_hardware_id_(local_device_id),
+         debug_string_("StablehloMlxDeviceDescription"),
+         to_string_(absl::StrFormat("%s(id=%d,pid=%d)", debug_string_,
+                                    id_.value(), process_index_)) {
+     TRACE_ME_MEMBER;
+   }
+
+   int id() const override {
+     TRACE_ME_MEMBER;
+     return id_.value();
+   }
+   int process_index() const override {
+     TRACE_ME_MEMBER;
+     return process_index_;
+   }
+   int local_hardware_id() const {
+     TRACE_ME_MEMBER;
+     return local_hardware_id_;
+   }
+
+   absl::string_view device_kind() const override {
+     TRACE_ME_MEMBER;
+     return "StablehloMlxDeviceDescription";
+   }
+
+   absl::string_view DebugString() const override {
+     TRACE_ME_MEMBER;
+     return debug_string_;
+   }
+
+   absl::string_view ToString() const override {
+     TRACE_ME_MEMBER;
+     return to_string_;
+   }
+
+   const absl::flat_hash_map<std::string, PjRtDeviceAttribute>& Attributes()
+       const override {
+     TRACE_ME_MEMBER;
+     return attributes_;
+   }
+
+  private:
+   PjRtGlobalDeviceId id_;
+   int process_index_;
+   int local_hardware_id_;
+   std::string debug_string_;
+   std::string to_string_;
+   absl::flat_hash_map<std::string, PjRtDeviceAttribute> attributes_ = {};
+ };
+
+ // Clients need devices, and clients own the devices.
+ class StablehloMlxDevice : public PjRtDevice {
+  public:
+   explicit StablehloMlxDevice(PjRtClient* client)
+       : PjRtDevice(), client_(client), description_(0, 0) {
+     TRACE_ME_MEMBER;
+   }
+
+   absl::string_view DebugString() const override {
+     TRACE_ME_MEMBER;
+     return "StablehloMlxDevice";
+   }
+
+   PjRtLocalDeviceId local_device_id() const override {
+     TRACE_ME_MEMBER;
+     return PjRtLocalDeviceId(local_hardware_id().value());
+   }
+
+   PjRtLocalHardwareId local_hardware_id() const override {
+     TRACE_ME_MEMBER;
+     return PjRtLocalHardwareId(description_.local_hardware_id());
+   }
+
+   PjRtClient* client() const override {
+     TRACE_ME_MEMBER;
+     return client_;
+   }
+
+   bool IsAddressable() const override {
+     TRACE_ME_MEMBER;
+     return process_index() == client()->process_index();
+   }
+
+   absl::Status TransferToInfeed(const LiteralSlice& literal) override {
+     TRACE_ME_MEMBER;
+     return UNIMPLEMENTED(TransferToInfeed);
+   }
+
+   absl::Status TransferFromOutfeed(MutableBorrowingLiteral literal) override {
+     TRACE_ME_MEMBER;
+     return UNIMPLEMENTED(TransferFromOutfeed);
+   }
+
+   void AttachDefaultMemorySpace(PjRtMemorySpace* memory_space) {
+     TRACE_ME_MEMBER;
+     memory_space_ = memory_space;
+   }
+
+   absl::Span<PjRtMemorySpace* const> memory_spaces() const override {
+     TRACE_ME_MEMBER;
+     return absl::MakeSpan(&memory_space_, 1);
+   }
+
+   absl::StatusOr<PjRtMemorySpace*> default_memory_space() const override {
+     TRACE_ME_MEMBER;
+     if (!memory_space_)
+       return absl::InternalError("Plugin memory space unset.");
+
+     return memory_space_;
+   }
+
+   std::unique_ptr<ScopedAsyncTrackingEvent> CreateAsyncTrackingEvent(
+       absl::string_view description) const override {
+     TRACE_ME_MEMBER;
+     LOG(FATAL) << "Plugin does not implement CreateAsyncTrackingEvent.";
+     return nullptr;
+   }
+
+   const PjRtDeviceDescription& description() const override {
+     TRACE_ME_MEMBER;
+     return description_;
+   }
+
+  private:
+   PjRtClient* client_;
+   PjRtMemorySpace* memory_space_;  // unpinned memory owned by client
+   StablehloMlxDeviceDescription description_;
+ };
+
+ // Device Description
+ std::unique_ptr<PjRtDeviceDescription> GetStablehloMlxDeviceDescription(
+     int process_id, int local_device_id) {
+   return std::make_unique<StablehloMlxDeviceDescription>(process_id,
+                                                                local_device_id);
+ }
+
+ // Mlx Device
+ std::unique_ptr<PjRtDevice> GetStablehloMlxDevice(PjRtClient* client) {
+   return std::make_unique<StablehloMlxDevice>(client);
+ }
+
+ void AttachStablehloMlxMemorySpace(PjRtDevice* device,
+                                          PjRtMemorySpace* memory_space) {
+   auto stablehlo_device = dynamic_cast<StablehloMlxDevice*>(device);
+   if (stablehlo_device == nullptr) {
+     LOG(FATAL) << "Plugin cannot attach memory space to device of kind "
+                << device->device_kind();
+     return;
+   }
+   stablehlo_device->AttachDefaultMemorySpace(memory_space);
+ }
+
+ }  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/device.h b/xla/pjrt/plugin/mlx/device.h
new file mode 100644
index 0000000000..74fecc8bf7
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/device.h
@@ -0,0 +1,37 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_DEVICE_H_
+ #define XLA_PJRT_PLUGIN_STABLEHLO_MLX_DEVICE_H_
+
+ #include <memory>
+
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/pjrt_compiler.h"
+ #include "xla/pjrt/pjrt_device_description.h"
+
+ namespace mlir::stablehlo {
+
+ // Device Description
+ std::unique_ptr<xla::PjRtDeviceDescription>
+ GetStablehloMlxDeviceDescription(int process_id, int local_device_id);
+
+ // MLX Device
+ std::unique_ptr<xla::PjRtDevice> GetStablehloMlxDevice(
+     xla::PjRtClient* client);
+
+ void AttachStablehloMlxMemorySpace(xla::PjRtDevice* device,
+                                          xla::PjRtMemorySpace* memory_space);
+
+ }  // namespace mlir::stablehlo
+
+ #endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_DEVICE_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/executable.cc b/xla/pjrt/plugin/mlx/executable.cc
new file mode 100644
index 0000000000..282ed8b165
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/executable.cc
@@ -0,0 +1,369 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/plugin/mlx/executable.h"
+
+ #include <memory>
+ #include <optional>
+ #include <utility>
+ #include <vector>
+
+ #include "absl/log/log.h"
+ #include "absl/status/status.h"
+ #include "absl/status/statusor.h"
+ #include "mlir/Bytecode/BytecodeWriter.h"
+ #include "mlir/Dialect/Func/IR/FuncOps.h"
+ #include "mlir/IR/AsmState.h"
+ #include "mlir/IR/BuiltinAttributes.h"
+ #include "mlir/IR/MLIRContext.h"
+ #include "mlir/IR/Operation.h"
+ #include "mlir/IR/OwningOpRef.h"
+ #include "mlir/Interfaces/DataLayoutInterfaces.h"
+ #include "mlir/Pass/PassManager.h"
+ #include "mlir/Support/LLVM.h"
+ #include "stablehlo/reference/Api.h"
+ #include "stablehlo/transforms/Passes.h"
+ #include "xla/hlo/translate/stablehlo.h"
+ #include "xla/mlir/utils/error_util.h"
+ #include "xla/mlir_hlo/mhlo/transforms/passes.h"
+ #include "xla/mlir_hlo/stablehlo_ext/transforms/passes.h"
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/pjrt/pjrt_executable.h"
+ #include "xla/pjrt/pjrt_future.h"
+ #include "xla/pjrt/plugin/mlx/buffer.h"
+ #include "xla/pjrt/plugin/mlx/logging.h"
+ #include "xla/service/computation_placer.h"
+ #include "tsl/platform/statusor.h"
+
+ #define DEBUG_TYPE "stablehlo-pjrt"
+
+ namespace mlir::stablehlo {
+
+ #define UNIMPLEMENTED(name) \
+   xla::Unimplemented("MlirPjrtBuffer::" #name " is not implemented")
+
+ using xla::DeviceAssignment;
+ using xla::PjRtBuffer;
+ using xla::PjRtClient;
+ using xla::PjRtDevice;
+ using xla::PjRtFuture;
+ using xla::PjRtLoadedExecutable;
+ using xla::PjRtMemorySpace;
+
+ mlir::OwningOpRef<ModuleOp> cloneIntoContext(ModuleOp module,
+                                              MLIRContext& context) {
+   // Clone the module into the context. MHLO->StableHLO just in case.
+   PassManager pm(module->getContext());
+   pm.addPass(mhlo::createHloLegalizeToStablehloPass());
+   if (failed(pm.run(module))) {
+     LOG(ERROR) << "Failed to convert MHLO to StableHLO";
+     return nullptr;
+   }
+
+   std::string bytecode;
+   llvm::raw_string_ostream os(bytecode);
+   mlir::BytecodeWriterConfig config;
+   mlir::OwningOpRef<mlir::ModuleOp> cloned = module.clone();
+   if (mlir::failed(mlir::writeBytecodeToFile(*cloned, os, config))) {
+     LOG(ERROR) << "Failed to write bytecode to string\n";
+     return nullptr;
+   }
+   return *parseStablehloModule(bytecode, context);
+ }
+
+ LogicalResult decomposeChloToStablehlo(ModuleOp module) {
+   PassManager pm(module->getContext());
+   stablehlo_ext::createChloLegalizeToStablehloPipeline(pm);
+   if (failed(pm.run(module))) {
+     return module->emitError() << "Failed to recompose CHLO";
+   }
+   return success();
+ }
+
+ std::optional<Operation*> getUnsupportedOp(ModuleOp module) {
+   std::optional<Operation*> unsupported_op(std::nullopt);
+   module.walk([&unsupported_op](Operation* op) {
+     auto cc = llvm::dyn_cast<stablehlo::CustomCallOp>(op);
+     if (cc) {
+       unsupported_op = op;
+       return WalkResult::interrupt();
+     }
+     return WalkResult::advance();
+   });
+   return unsupported_op;
+ }
+
+ LogicalResult runHardwareIndependentOptimizations(ModuleOp module) {
+   PassManager pm(module->getContext());
+   pm.addNestedPass<func::FuncOp>(
+       stablehlo::createStablehloAggressiveFolderPass());
+   pm.addNestedPass<func::FuncOp>(
+       stablehlo::createStablehloAggressiveSimplificationPass());
+   if (failed(pm.run(module))) {
+     return module->emitError()
+            << "Failed to run hardware independent optimizations";
+   }
+   return success();
+ }
+
+ class MlirLoadedExecutable : public PjRtLoadedExecutable {
+  public:
+   MlirLoadedExecutable(ModuleOp module, DeviceAssignment assignment,
+                        absl::Span<PjRtDevice* const> devices,
+                        PjRtClient* client)
+       : PjRtLoadedExecutable(),
+         name_("MlirLoadedExecutable"),
+         assignment_(assignment),
+         devices_(client->devices()),
+         client_(client),
+         context_(),
+         module_(cloneIntoContext(module, context_)) {
+     TRACE_ME_MEMBER;
+   }
+
+   static absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>> Compile(
+       ModuleOp module, DeviceAssignment assignment,
+       absl::Span<PjRtDevice* const> devices, PjRtClient* client) {
+     TRACE_ME;
+     mlir::BaseScopedDiagnosticHandler diagnostic_handler(module->getContext());
+     if (failed(decomposeChloToStablehlo(module))) {
+       return diagnostic_handler.ConsumeStatus();
+     }
+     if (auto unsupported_op = getUnsupportedOp(module)) {
+       LOG(ERROR) << "Unsupported op: " << ToString(*unsupported_op)
+                  << "\nFound in module: " << ToString(module);
+       return absl::UnimplementedError(
+           absl::StrCat("Unsupported op: ", ToString(*unsupported_op)));
+     }
+
+     // Simplify the graph using available HWI passes.
+     if (failed(runHardwareIndependentOptimizations(module))) {
+       return diagnostic_handler.ConsumeStatus();
+     }
+
+     auto executable = std::make_unique<MlirLoadedExecutable>(module, assignment,
+                                                              devices, client);
+
+     return executable;
+   }
+
+   PjRtClient* client() const override {
+     TRACE_ME_MEMBER;
+     return client_;
+   }
+
+   const DeviceAssignment& device_assignment() const override {
+     TRACE_ME_MEMBER;
+     return assignment_;
+   }
+
+   absl::Span<const PjRtLoadedExecutable::LogicalDeviceIds>
+   addressable_device_logical_ids() const override {
+     TRACE_ME_MEMBER;
+     LOG_UNIMPLEMENTED(addressable_device_logical_ids);
+     return {};
+   }
+
+   absl::Span<PjRtDevice* const> addressable_devices() const override {
+     TRACE_ME_MEMBER;
+     return devices_;
+   }
+
+   // Helper function to get default mem from device.
+   PjRtMemorySpace* get_default_memory_space() const {
+     TRACE_ME_MEMBER;
+     return devices_[0]->default_memory_space().value_or(nullptr);
+   }
+
+   absl::StatusOr<PjRtLoadedExecutable::Result> ExecuteWithMlxInterpreter(
+       absl::Span<PjRtBuffer* const> argument_handles, ModuleOp module,
+       PjRtDevice* device, bool fill_future) {
+     TRACE_ME_MEMBER;
+     SmallVector<mlir::DenseElementsAttr> inputs;
+     for (auto* arg : argument_handles) {
+       TF_ASSIGN_OR_RETURN(auto mlirArg, GetAttributeFromBuffer(arg));
+       auto mlirArgInModuleContext =
+           CloneIntoContext(mlirArg, *module->getContext());
+       inputs.push_back(mlirArgInModuleContext);
+     }
+     LOG(INFO) << "EvalModule:\n" << ToString(module) << "\n";
+     LOG(INFO) << "Inputs: " << ToString(inputs) << "\n";
+     InterpreterConfiguration config;
+     FailureOr<SmallVector<DenseElementsAttr>> result =
+         evalModule(module, inputs, config);
+     if (failed(result)) {
+       return absl::InternalError("Failed to execute module");
+     }
+     LOG(INFO) << "Results: " << ToString(result.value()) << "\n";
+
+     // Naive memory space selection, only using CPU global memory.
+     PjRtMemorySpace* memory_space =
+         device->default_memory_space().value_or(nullptr);
+     std::vector<std::unique_ptr<PjRtBuffer>> buffer_results;
+     for (auto res : result.value()) {
+       buffer_results.push_back(
+           CreateMlirBufferFromAttribute(res, memory_space));
+     }
+
+     std::optional<PjRtFuture<>> future;
+     if (fill_future) {
+       // Synchronous! To make async, this would need to return a future that is
+       // ready when the computation is done.
+       future = PjRtFuture<>(absl::OkStatus());
+     }
+     return PjRtLoadedExecutable::Result{future, std::move(buffer_results)};
+   }
+
+   absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(
+       absl::Span<const std::vector<PjRtBuffer*>> argument_handles,
+       const xla::ExecuteOptions& options,
+       std::optional<std::vector<PjRtFuture<>>>& returned_futures) override {
+     TRACE_ME_MEMBER;
+     if (argument_handles.size() != 1) {
+       // One arg handle per device.
+       return absl::InvalidArgumentError(
+           "MlirLoadedExecutable::Execute only supports a single argument "
+           "vector");
+     }
+
+     // Single device, synchronous, can always use 0.
+     PjRtDevice* device = devices_[0];
+     bool fill_future = returned_futures.has_value();
+     TF_ASSIGN_OR_RETURN(
+         PjRtLoadedExecutable::Result result,
+         ExecuteWithMlxInterpreter(argument_handles[0], module_.get(),
+                                         device, fill_future));
+     std::vector<std::vector<std::unique_ptr<PjRtBuffer>>> results;
+     results.push_back(std::move(result.buffers));
+     if (returned_futures.has_value()) {
+       returned_futures->push_back(std::move(result.future.value()));
+     }
+     return results;
+   }
+
+   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(
+       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,
+       const xla::ExecuteOptions& options,
+       std::optional<PjRtFuture<>>& returned_future, bool fill_future) override {
+     TRACE_ME_MEMBER;
+     // Synchronous! To make async, have the device make a buffer with a ready
+     // future that is ready when the computation is done / buffer is ready.
+     TF_ASSIGN_OR_RETURN(
+         PjRtLoadedExecutable::Result result,
+         ExecuteWithMlxInterpreter(argument_handles, module_.get(), device,
+                                         fill_future));
+     if (returned_future.has_value() && fill_future) {
+       returned_future = std::move(result.future);
+     }
+     return std::move(result.buffers);
+   }
+
+   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(
+       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,
+       const xla::ExecuteOptions& options,
+       std::optional<PjRtFuture<>>& returned_future, bool fill_future) override {
+     TRACE_ME_MEMBER;
+     // Synchronous! To make async, have the device make a buffer with a ready
+     // future that is ready when the computation is done / buffer is ready.
+     TF_ASSIGN_OR_RETURN(
+         PjRtLoadedExecutable::Result result,
+         ExecuteWithMlxInterpreter(argument_handles, module_.get(), device,
+                                         fill_future));
+     if (returned_future.has_value() && fill_future) {
+       returned_future = std::move(result.future);
+     }
+     return std::move(result.buffers);
+   }
+
+   void Delete() override {
+     TRACE_ME_MEMBER;
+     module_.release();
+     module_ = nullptr;
+   }
+   bool IsDeleted() override {
+     TRACE_ME_MEMBER;
+     return !module_;
+   }
+
+   // PjRtExecutable API.
+   int num_replicas() const override {
+     TRACE_ME_MEMBER;
+     return assignment_.replica_count();
+   }
+   int num_partitions() const override {
+     TRACE_ME_MEMBER;
+     return assignment_.computation_count();
+   }
+   int64_t SizeOfGeneratedCodeInBytes() const override {
+     // No generated code.. so just return 1.
+     TRACE_ME_MEMBER;
+     return 1;
+   }
+   absl::string_view name() const override {
+     TRACE_ME_MEMBER;
+     return name_;
+   }
+
+   absl::StatusOr<std::vector<std::shared_ptr<xla::HloModule>>> GetHloModules()
+       const override {
+     // TODO: This shouldn't be needed for an MLIR plugin, its only used in the
+     // JAX layer for determining output sharding, which exists on the mlir
+     // module.
+     TRACE_ME_MEMBER;
+     auto moduleClone = llvm::cast<ModuleOp>(module_.get()->clone());
+     TF_ASSIGN_OR_RETURN(auto hlo_module,
+                         xla::ConvertStablehloToHlo(moduleClone));
+     return std::vector<std::shared_ptr<xla::HloModule>>{std::move(hlo_module)};
+   }
+
+   absl::StatusOr<std::vector<std::vector<absl::string_view>>>
+   GetOutputMemoryKinds() const override {
+     TRACE_ME_MEMBER;
+     return UNIMPLEMENTED(GetOutputMemoryKinds);
+   }
+
+   absl::StatusOr<std::string> FingerprintExecutable() const override {
+     TRACE_ME_MEMBER;
+     return UNIMPLEMENTED(FingerprintExecutable);
+   }
+
+  private:
+   std::string name_;
+   DeviceAssignment assignment_;
+   absl::Span<PjRtDevice* const> devices_;
+   PjRtClient* client_;
+
+   // MLIR
+   MLIRContext context_;
+   mlir::OwningOpRef<ModuleOp> module_;
+ };
+
+ absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>>
+ StablehloMlxCompile(mlir::ModuleOp module, DeviceAssignment assignment,
+                           PjRtClient* client) {
+   TRACE_ME;
+   return MlirLoadedExecutable::Compile(module, assignment, client->devices(),
+                                        client);
+ }
+
+ absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>>
+ StablehloMlxCompile(xla::XlaComputation const& computation,
+                           xla::DeviceAssignment assignment,
+                           xla::PjRtClient* client) {
+   TRACE_ME;
+   MLIRContext context;
+   TF_ASSIGN_OR_RETURN(auto module,
+                       ConvertHloToStablehlo(context, &computation.proto()));
+   return StablehloMlxCompile(module.get(), assignment, client);
+ }
+
+ }  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/executable.h b/xla/pjrt/plugin/mlx/executable.h
new file mode 100644
index 0000000000..2aba7810ba
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/executable.h
@@ -0,0 +1,37 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_EXECUTABLE_H_
+ #define XLA_PJRT_PLUGIN_STABLEHLO_MLX_EXECUTABLE_H_
+
+ #include <memory>
+
+ #include "mlir/IR/BuiltinOps.h"
+ #include "xla/hlo/builder/xla_computation.h"
+ #include "xla/pjrt/pjrt_client.h"
+ #include "xla/service/computation_placer.h"
+
+ namespace mlir::stablehlo {
+
+ absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>>
+ StablehloMlxCompile(mlir::ModuleOp module,
+                           xla::DeviceAssignment assignment,
+                           xla::PjRtClient* client);
+
+ absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>>
+ StablehloMlxCompile(xla::XlaComputation const& computation,
+                           xla::DeviceAssignment assignment,
+                           xla::PjRtClient* client);
+
+ }  // namespace mlir::stablehlo
+
+ #endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_EXECUTABLE_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/logging.cc b/xla/pjrt/plugin/mlx/logging.cc
new file mode 100644
index 0000000000..8b2c970d4c
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/logging.cc
@@ -0,0 +1,69 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/plugin/mlx/logging.h"
+
+ #include <cstdlib>
+
+ #include "absl/base/log_severity.h"
+ #include "absl/log/globals.h"
+ #include "llvm/Support/raw_ostream.h"
+ #include "mlir/IR/Attributes.h"
+ #include "mlir/IR/BuiltinAttributes.h"
+ #include "mlir/IR/Operation.h"
+
+ namespace mlir::stablehlo {
+
+ std::string ToString(mlir::Attribute attr) {
+   std::string out;
+   llvm::raw_string_ostream os(out);
+   attr.print(os);
+   return out;
+ }
+
+ std::string ToString(SmallVector<DenseElementsAttr> attrs) {
+   std::string out;
+   llvm::raw_string_ostream os(out);
+   os << "[";
+   bool first = true;
+   for (auto attr : attrs) {
+     if (!first) os << ", ";
+     first = false;
+     attr.print(os);
+   }
+   os << "]";
+   return out;
+ }
+
+ std::string ToString(Operation* op) {
+   std::string out;
+   llvm::raw_string_ostream os(out);
+   os << *op;
+   return out;
+ }
+
+ void SetupLogLevelFromEnv() {
+   absl::SetMinLogLevel(absl::LogSeverityAtLeast::kError);
+   const char* log_env = std::getenv("PJRT_LOG_LEVEL");
+   if (!log_env) return;
+   if (strcmp(log_env, "INFO") == 0) {
+     absl::SetMinLogLevel(absl::LogSeverityAtLeast::kInfo);
+   } else if (strcmp(log_env, "WARNING") == 0) {
+     absl::SetMinLogLevel(absl::LogSeverityAtLeast::kWarning);
+   } else if (strcmp(log_env, "ERROR") == 0) {
+     absl::SetMinLogLevel(absl::LogSeverityAtLeast::kError);
+   } else {
+     LOG(ERROR) << "Invalid PJRT_LOG_LEVEL: " << log_env;
+   }
+ }
+
+ }  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/logging.h b/xla/pjrt/plugin/mlx/logging.h
new file mode 100644
index 0000000000..2945b6a325
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/logging.h
@@ -0,0 +1,39 @@
+/* Copyright 2024 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_LOGGING_H_
+ #define XLA_PJRT_PLUGIN_STABLEHLO_MLX_LOGGING_H_
+
+ // This file has some joint logging to allow LOG and VLOG to play well with
+ // MLIR data structures
+
+ #include "absl/log/log.h"
+ #include "mlir/IR/Attributes.h"
+ #include "mlir/IR/BuiltinAttributes.h"
+
+ #define LOG_UNIMPLEMENTED(name) \
+   LOG(ERROR) << "MlirPjrtBuffer::" #name " is not implemented"
+
+ #define TRACE_ME LOG(INFO) << __func__;
+
+ #define TRACE_ME_MEMBER LOG(INFO) << __func__ << "(" << (void*)this << ")\n";
+
+ namespace mlir::stablehlo {
+ std::string ToString(mlir::Attribute attr);
+ std::string ToString(llvm::SmallVector<mlir::DenseElementsAttr> attrs);
+ std::string ToString(Operation* op);
+
+ // Looks for `PJRT_LOG_LEVEL = INFO|WARNING|ERROR` in env variables.
+ void SetupLogLevelFromEnv();
+ }  // namespace mlir::stablehlo
+
+ #endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_LOGGING_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/plugin_pjrt_test.cc b/xla/pjrt/plugin/mlx/plugin_pjrt_test.cc
new file mode 100644
index 0000000000..bb14ed4dde
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/plugin_pjrt_test.cc
@@ -0,0 +1,34 @@
+/* Copyright 2022 The OpenXLA Authors.
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+     http://www.apache.org/licenses/LICENSE-2.0
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ ==============================================================================*/
+
+ #include "xla/pjrt/c/pjrt_c_api_test.h"
+ #include "xla/pjrt/c/pjrt_c_api_wrapper_impl.h"
+ #include "xla/pjrt/pjrt_client_test.h"
+ #include "xla/pjrt/plugin/mlx/client_c_pjrt.h"
+ #include "xla/pjrt/plugin/mlx/client_cpp_pjrt.h"
+
+ namespace pjrt {
+ namespace {
+
+ const bool kUnused =
+     (RegisterPjRtCApiTestFactory([]() { return GetPjrtApi(); },
+                                  /*platform_name=*/"stablehlo_mlx"),
+      true);
+
+ const bool kUnused2 =
+     (xla::RegisterTestClientFactory([]() {
+        return mlir::stablehlo::CreateStablehloMlxPjrtClient();
+      }),
+      true);
+
+ }  // namespace
+ }  // namespace pjrt
\ No newline at end of file
