diff --git a/xla/pjrt/plugin/mlx/BUILD b/xla/pjrt/plugin/mlx/BUILD
new file mode 100644
index 0000000000..ae444f558f
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/BUILD
@@ -0,0 +1,171 @@
+load("//xla:xla.bzl", "xla_cc_binary", "xla_cc_test")
+
+package(
+    # copybara:uncomment default_applicable_licenses = ["//tensorflow:license"],
+    default_visibility = ["//visibility:public"],
+    licenses = ["notice"],
+)
+
+cc_library(
+    name = "buffer",
+    srcs = ["buffer.cc"],
+    hdrs = ["buffer.h"],
+    deps = [
+        ":logging",
+        "//xla:literal",
+        "//xla:shape_util",
+        "//xla:util",
+        "//xla/hlo/translate/hlo_to_mhlo:hlo_utils",
+        "//xla/hlo/translate/mhlo_to_hlo:literal_exporter",
+        "//xla/hlo/translate/mhlo_to_hlo:type_to_shape",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_compiler",
+        "//xla/pjrt:pjrt_future",
+        "@com_google_absl//absl/functional:any_invocable",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/status:statusor",
+        "@llvm-project//llvm:Support",
+        "@llvm-project//mlir:AsmParser",
+        "@llvm-project//mlir:IR",
+        "@llvm-project//mlir:Support",
+    ],
+)
+
+cc_library(
+    name = "executable",
+    srcs = ["executable.cc"],
+    hdrs = ["executable.h"],
+    deps = [
+        "@mlx//:libmlx",
+        ":buffer",
+        ":logging",
+        "//xla/hlo/builder:xla_computation",
+        "//xla/hlo/translate:stablehlo",
+        "//xla/mlir/utils:error_util",
+        "//xla/mlir_hlo:mhlo_passes",
+        "//xla/mlir_hlo:stablehlo_extension_passes",
+        "//xla/pjrt:mlir_to_hlo",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_executable",
+        "//xla/pjrt:pjrt_future",
+        "//xla/service:computation_placer_hdr",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/status:statusor",
+        "@llvm-project//llvm:Support",
+        "@llvm-project//mlir:AsmParser",
+        "@llvm-project//mlir:BytecodeWriter",
+        "@llvm-project//mlir:DataLayoutInterfaces",
+        "@llvm-project//mlir:FuncDialect",
+        "@llvm-project//mlir:IR",
+        "@llvm-project//mlir:Parser",
+        "@llvm-project//mlir:Pass",
+        "@llvm-project//mlir:Support",
+        "@llvm-project//mlir:Transforms",
+        "@stablehlo//:reference_api",
+        "@stablehlo//:stablehlo_passes",
+        "@tsl//tsl/platform:statusor",
+    ],
+)
+
+cc_library(
+    name = "device",
+    srcs = ["device.cc"],
+    hdrs = ["device.h"],
+    deps = [
+        ":logging",
+        "//xla:util",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_common",
+        "//xla/pjrt:pjrt_compiler",
+        "//xla/pjrt:pjrt_device_description",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings:str_format",
+        "@com_google_absl//absl/strings:string_view",
+        "@com_google_absl//absl/types:span",
+    ],
+)
+
+cc_library(
+    name = "client_cpp_pjrt",
+    srcs = [
+        "client_cpp_pjrt.cc",
+    ],
+    hdrs = [
+        "client_cpp_pjrt.h",
+    ],
+    deps = [
+        ":buffer",
+        ":device",
+        ":executable",
+        ":logging",
+        "//xla:literal",
+        "//xla:shape_util",
+        "//xla:util",
+        "//xla/pjrt:host_memory_spaces",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt:pjrt_common",
+        "//xla/pjrt:pjrt_compiler",
+        "//xla/tsl/framework:allocator",
+        "@com_google_absl//absl/status:statusor",
+        "@com_google_absl//absl/strings:str_format",
+        "@com_google_absl//absl/strings:string_view",
+        "@com_google_absl//absl/types:span",
+        "@tsl//tsl/platform:fingerprint",
+    ],
+)
+
+cc_library(
+    name = "client_c_pjrt",
+    srcs = [
+        "client_c_pjrt.cc",
+    ],
+    hdrs = ["client_c_pjrt.h"],
+    deps = [
+        ":client_cpp_pjrt",
+        "//xla/pjrt:pjrt_client",
+        "//xla/pjrt/c:pjrt_c_api_hdrs",
+        "//xla/pjrt/c:pjrt_c_api_layouts_extension_hdrs",
+        "//xla/pjrt/c:pjrt_c_api_wrapper_impl",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/strings:string_view",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "logging",
+    srcs = ["logging.cc"],
+    hdrs = ["logging.h"],
+    deps = [
+        "@com_google_absl//absl/base:log_severity",
+        "@com_google_absl//absl/log",
+        "@com_google_absl//absl/log:globals",
+        "@llvm-project//llvm:Support",
+        "@llvm-project//mlir:AsmParser",
+        "@llvm-project//mlir:DataLayoutInterfaces",
+        "@llvm-project//mlir:IR",
+    ],
+)
+
+xla_cc_test(
+    name = "plugin_pjrt_test",
+    srcs = ["plugin_pjrt_test.cc"],
+    deps = [
+        ":client_c_pjrt",
+        ":client_cpp_pjrt",
+        "//xla/pjrt:pjrt_client_test_common",
+        "//xla/pjrt/c:pjrt_c_api_test_common",
+        "//xla/pjrt/c:pjrt_c_api_wrapper_impl",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+xla_cc_binary(
+    name = "stablehlo_mlx_plugin.so",
+    linkshared = True,
+    deps = [
+        ":client_c_pjrt",
+        "@mlx//:libmlx",
+    ],
+)
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/buffer.cc b/xla/pjrt/plugin/mlx/buffer.cc
new file mode 100644
index 0000000000..ccb6dd12ac
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/buffer.cc
@@ -0,0 +1,331 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "xla/pjrt/plugin/mlx/buffer.h"
+
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "absl/functional/any_invocable.h"
+#include "absl/log/log.h"
+#include "absl/status/statusor.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/raw_ostream.h"
+#include "mlir/AsmParser/AsmParser.h"
+#include "mlir/IR/Attributes.h"
+#include "mlir/IR/Builders.h"
+#include "mlir/IR/BuiltinAttributes.h"
+#include "mlir/IR/BuiltinTypeInterfaces.h"
+#include "mlir/IR/MLIRContext.h"
+#include "mlir/Support/DebugStringHelper.h"
+#include "xla/hlo/translate/hlo_to_mhlo/hlo_utils.h"
+#include "xla/hlo/translate/mhlo_to_hlo/literal_exporter.h"
+#include "xla/hlo/translate/mhlo_to_hlo/type_to_shape.h"
+#include "xla/literal.h"
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/pjrt_compiler.h"
+#include "xla/pjrt/pjrt_future.h"
+#include "xla/pjrt/plugin/mlx/logging.h"
+#include "xla/shape.h"
+#include "xla/util.h"
+
+namespace mlir::stablehlo {
+
+using xla::MutableLiteralBase;
+using xla::PjRtBuffer;
+using xla::PjRtClient;
+using xla::PjRtDevice;
+using xla::PjRtFuture;
+using xla::PjRtMemorySpace;
+using xla::PjRtPlatformId;
+using xla::Shape;
+
+#define UNIMPLEMENTED(name) \
+  xla::Unimplemented("MlirPjrtBuffer::" #name " is not implemented")
+
+class MlirPjrtBuffer : public PjRtBuffer {
+ public:
+  MlirPjrtBuffer(const Shape& shape, PjRtMemorySpace* memory_space)
+      : xla::PjRtBuffer(),
+        context_(),
+        buffer_(),
+        shape_(shape),
+        memory_space_(memory_space) {
+    // TRACE_ME_MEMBER;
+  }
+
+  class MlirClonedExternalReference : public ExternalReference {
+   public:
+    explicit MlirClonedExternalReference(PjRtBuffer* buffer,
+                                         PjRtMemorySpace* memory_space)
+        : buffer_() {
+      // TRACE_ME_MEMBER;
+      auto mlir_buffer = GetAttributeFromBuffer(buffer);
+      if (!mlir_buffer.ok()) {
+        LOG(ERROR) << "Could not get attribute from buffer: "
+                   << mlir_buffer.status();
+      }
+      buffer_ =
+          CreateMlirBufferFromAttribute(mlir_buffer.value(), memory_space);
+      data_ptr_ = (void*)mlir_buffer.value().getRawData().data();
+    }
+
+   private:
+    std::unique_ptr<PjRtBuffer> buffer_;
+  };
+
+  // All buffers are managed by the MLIR Context
+  ~MlirPjrtBuffer() override = default;
+
+  MlirPjrtBuffer(const MlirPjrtBuffer&) = delete;
+  MlirPjrtBuffer(MlirPjrtBuffer&&) = delete;
+  MlirPjrtBuffer& operator=(const MlirPjrtBuffer&) = delete;
+  MlirPjrtBuffer& operator=(MlirPjrtBuffer&&) = delete;
+
+  static std::unique_ptr<MlirPjrtBuffer> CreateFromLiteral(
+      const xla::LiteralSlice& literal, xla::PjRtMemorySpace* memory_space) {
+    TRACE_ME;
+    LOG(INFO) << "CreateFromLiteral: " << literal.ToString() << "\n";
+    auto buffer =
+        std::make_unique<MlirPjrtBuffer>(literal.shape(), memory_space);
+    LOG(INFO) << "CreateFromLiteral -> " << (void*)buffer.get() << "\n";
+    mlir::Builder builder(&buffer->context_);
+    auto attr = xla::CreateDenseElementsAttrFromLiteral(literal, builder);
+    if (!attr.ok()) {
+      LOG(ERROR) << "Could not create dense elements attr from literal: "
+                 << attr.status();
+      return nullptr;
+    }
+    buffer->buffer_ = attr.value();
+    return buffer;
+  }
+
+  static std::unique_ptr<MlirPjrtBuffer> CreateFromAttribute(
+      DenseElementsAttr attr, xla::PjRtMemorySpace* memory_space) {
+    TRACE_ME;
+
+    // MLIR type to xla shape:
+    Shape shape = xla::TypeToShape(attr.getType());
+    auto buffer = std::make_unique<MlirPjrtBuffer>(shape, memory_space);
+    buffer->buffer_ = CloneIntoContext(attr, buffer->context_);
+    LOG(INFO) << "CreateFromAttribute(" << ToString(attr) << ") -> "
+              << (void*)buffer.get() << "\n";
+    return buffer;
+  }
+
+  const Shape& on_device_shape() const override {
+    // TRACE_ME_MEMBER;
+    return shape_;
+  }
+  absl::StatusOr<Shape> logical_on_device_shape() override {
+    // TRACE_ME_MEMBER;
+    return shape_;
+  }
+
+  PjRtPlatformId platform_id() const {
+    // TRACE_ME_MEMBER;
+    return client()->platform_id();
+  }
+  absl::string_view platform_name() const {
+    // TRACE_ME_MEMBER;
+    return client()->platform_name();
+  }
+
+  bool IsEmptyTuple() const {
+    // TRACE_ME_MEMBER;
+    return shape_.IsTuple() && shape_.tuple_shapes().empty();
+  }
+
+  // Buffer knows device + client per older design, should only need
+  // memory_space.
+  PjRtMemorySpace* memory_space() const override {
+    // TRACE_ME_MEMBER;
+    return memory_space_;
+  }
+  PjRtDevice* device() const override {
+    // TRACE_ME_MEMBER;
+    return memory_space_->devices().front();
+  }
+  PjRtClient* client() const override {
+    // TRACE_ME_MEMBER;
+    return memory_space_->client();
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer::ExternalReference>>
+  AcquireExternalReference() override {
+    // TRACE_ME_MEMBER;
+    return std::make_unique<MlirClonedExternalReference>(this, memory_space_);
+  }
+
+  xla::PjRtFuture<> ToLiteral(xla::MutableLiteralBase* literal) override {
+    // TRACE_ME_MEMBER;
+    if (IsEmptyTuple()) {
+      return PjRtFuture<>(
+          xla::InvalidArgument("ToLiteral called on empty tuple"));
+    }
+
+    absl::StatusOr<xla::Literal> to_copy =
+        mhlo::CreateLiteralFromAttribute(buffer_, {});
+    if (!to_copy.ok()) return PjRtFuture<>(to_copy.status());
+
+    // Synchronous! To make async, make the buffer, start the copy, and return a
+    // future that is ready when the copy is done.
+    auto status = literal->CopyFrom(to_copy.value());
+    if (!status.ok()) return PjRtFuture<>(status);
+    return PjRtFuture<>(absl::OkStatus());
+  }
+
+  PjRtFuture<> LazyToLiteral(
+      absl::AnyInvocable<absl::StatusOr<MutableLiteralBase*>() &&> generator)
+      override {
+    // TRACE_ME_MEMBER;
+    auto buffer = std::move(generator)();
+    if (!buffer.ok()) return PjRtFuture<>(buffer.status());
+    return ToLiteral(buffer.value());
+  }
+
+  absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override {
+    // This is needed by AcquireExternalReference, for framework figuring out
+    // how to read the underlying buffer data.
+    // TRACE_ME_MEMBER;
+    if (!buffer_) return 0;
+    return buffer_.getRawData().size();
+  }
+
+  PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,
+                             int64_t transfer_size) override {
+    // TRACE_ME_MEMBER;
+    return PjRtFuture<>(UNIMPLEMENTED(CopyRawToHost));
+  }
+
+  absl::StatusOr<std::unique_ptr<ExternalReference>>
+  ReleaseDeviceMemoryOwnership(bool wait_for_operations_to_complete) override {
+    // TRACE_ME_MEMBER;
+    auto external_ref = AcquireExternalReference();
+    Delete();
+    return external_ref;
+  }
+
+  // Remove the buffer if deleted.
+  // Note: deleted and uninitialized appear the same in this scenario.
+  // Consider changing to mlir::NoneType when deleted.
+  void Delete() override {
+    // TRACE_ME_MEMBER;
+    buffer_ = {};
+  }
+
+  bool IsDeleted() override {
+    // TRACE_ME_MEMBER;
+    return !buffer_;
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CopyToDevice(
+      xla::PjRtDevice* dst_device) override {
+    // TRACE_ME_MEMBER;
+    return CopyToMemorySpace(
+        dst_device->default_memory_space().value_or(nullptr));
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CopyToMemorySpace(
+      xla::PjRtMemorySpace* dst_memory_space) override {
+    // TRACE_ME_MEMBER;
+    return CreateMlirBufferFromAttribute(buffer_, dst_memory_space);
+  }
+
+  void CopyToRemoteDevice(
+      xla::PjRtFuture<std::string> serialized_descriptor,
+      xla::PjRtBuffer::RemoteSendCallback on_done) override {
+    // TRACE_ME_MEMBER;
+    on_done(UNIMPLEMENTED(CopyToRemoteDevice), false);
+  }
+
+  void CopyToRemoteDeviceScattered(
+      xla::PjRtFuture<std::vector<std::string>> serialized_descriptors,
+      std::vector<RemoteSendCallback> callbacks,
+      const xla::PjRtBuffer::ScatterDetails& scatter_details) override {
+    // TRACE_ME_MEMBER;
+    for (auto cb : callbacks) {
+      cb(UNIMPLEMENTED(CopyToRemoteDeviceScattered), false);
+    }
+  }
+
+  xla::PjRtFuture<> GetReadyFuture() override {
+    // TRACE_ME_MEMBER;
+    LOG(INFO) << "GetReadyFuture(" << (void*)this << ")\n";
+    // Synchronous! To make async, have the device make a buffer with a ready
+    // future that is ready when the computation is done / buffer is ready.
+    return PjRtFuture<>(absl::OkStatus());
+  }
+
+  bool IsOnCpu() const override {
+    // If buffer is on CPU, it will be shared with framework via
+    // GetExternalReference, lse it is copied back to host.
+    // Since we are using reference interpreter, we are running on CPU in a
+    // shared memory space.
+    // TRACE_ME_MEMBER;
+    return false;
+  }
+
+  mlir::DenseElementsAttr GetBufferAttribute() const { return buffer_; }
+
+ private:
+  MLIRContext context_;
+  mlir::DenseElementsAttr buffer_;
+
+  xla::Shape shape_;
+  PjRtMemorySpace* memory_space_;
+};
+
+std::unique_ptr<PjRtBuffer> CreateMlirBufferFromLiteral(
+    const xla::LiteralSlice& literal, xla::PjRtMemorySpace* memory_space) {
+  TRACE_ME;
+  return MlirPjrtBuffer::CreateFromLiteral(literal, memory_space);
+}
+
+std::unique_ptr<PjRtBuffer> CreateMlirBufferFromAttribute(
+    DenseElementsAttr attr, xla::PjRtMemorySpace* memory_space) {
+  TRACE_ME;
+  return MlirPjrtBuffer::CreateFromAttribute(attr, memory_space);
+}
+
+std::unique_ptr<PjRtBuffer> CreateMlirBufferUninitizlied(
+    const Shape& shape, PjRtMemorySpace* memory_space) {
+  TRACE_ME;
+  return std::make_unique<MlirPjrtBuffer>(shape, memory_space);
+}
+
+absl::StatusOr<mlir::DenseElementsAttr> GetAttributeFromBuffer(
+    xla::PjRtBuffer* buffer) {
+  TRACE_ME;
+  if (buffer == nullptr || buffer->IsDeleted()) {
+    return xla::InvalidArgument("Buffer is null or deleted");
+  }
+  auto mlir_buffer = dynamic_cast<MlirPjrtBuffer*>(buffer);
+  if (mlir_buffer == nullptr) {
+    return xla::InvalidArgument("Buffer is not a MlirPjrtBuffer");
+  }
+  LOG(INFO) << "GetAttributeFromBuffer(" << (void*)buffer << ") -> "
+            << ToString(mlir_buffer->GetBufferAttribute()) << "\n";
+  return mlir_buffer->GetBufferAttribute();
+}
+
+DenseElementsAttr CloneIntoContext(DenseElementsAttr attr,
+                                   MLIRContext& context) {
+  Type type = mlir::parseType(mlir::debugString(attr.getType()), &context);
+  return DenseElementsAttr::getFromRawBuffer(llvm::cast<ShapedType>(type),
+                                             attr.getRawData());
+}
+
+}  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/buffer.h b/xla/pjrt/plugin/mlx/buffer.h
new file mode 100644
index 0000000000..8de53507a7
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/buffer.h
@@ -0,0 +1,37 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_BUFFER_H_
+#define XLA_PJRT_PLUGIN_STABLEHLO_MLX_BUFFER_H_
+
+#include <memory>
+
+#include "mlir/IR/BuiltinAttributes.h"
+#include "xla/literal.h"
+#include "xla/pjrt/pjrt_client.h"
+
+namespace mlir::stablehlo {
+
+std::unique_ptr<xla::PjRtBuffer> CreateMlirBufferFromLiteral(
+    const xla::LiteralSlice& literal, xla::PjRtMemorySpace* memory_space);
+std::unique_ptr<xla::PjRtBuffer> CreateMlirBufferFromAttribute(
+    DenseElementsAttr attribute, xla::PjRtMemorySpace* memory_space);
+std::unique_ptr<xla::PjRtBuffer> CreateMlirBufferUninitizlied(
+    const xla::Shape& shape, xla::PjRtMemorySpace* memory_space);
+absl::StatusOr<DenseElementsAttr> GetAttributeFromBuffer(
+    xla::PjRtBuffer* buffer);
+DenseElementsAttr CloneIntoContext(DenseElementsAttr attr,
+                                   MLIRContext& context);
+
+}  // namespace mlir::stablehlo
+
+#endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_BUFFER_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_c_pjrt.cc b/xla/pjrt/plugin/mlx/client_c_pjrt.cc
new file mode 100644
index 0000000000..4ce81dcc46
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_c_pjrt.cc
@@ -0,0 +1,72 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "xla/pjrt/plugin/mlx/client_c_pjrt.h"
+
+#include <cstdio>
+#include <memory>
+#include <utility>
+
+#include "absl/status/status.h"
+#include "absl/strings/string_view.h"
+#include "xla/pjrt/c/pjrt_c_api.h"
+#include "xla/pjrt/c/pjrt_c_api_layouts_extension.h"
+#include "xla/pjrt/c/pjrt_c_api_wrapper_impl.h"
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/plugin/mlx/client_cpp_pjrt.h"
+
+namespace mlir::stablehlo {
+
+using xla::PjRtClient;
+
+std::unique_ptr<PjRtClient> GetPluginPjRtClient() {
+  return CreateStablehloMlxPjrtClient();
+}
+
+// Create my client
+PJRT_Error* PJRT_StablehloMlxClient_Create(PJRT_Client_Create_Args* args) {
+  std::unique_ptr<PjRtClient> client = GetPluginPjRtClient();
+  args->client = pjrt::CreateWrapperClient(std::move(client));
+  // printf("Creating PJRT Client from client\n");
+  return nullptr;
+}
+
+PJRT_Error* PJRT_StablehloMlxExecuteContext_Create(
+    PJRT_ExecuteContext_Create_Args* args) {
+  return new PJRT_Error{absl::UnimplementedError(
+      "ExecuteContext not supported for client execution.")};
+}
+
+PJRT_Error* PJRT_StablehloMlxDeviceTopology_Create(
+    PJRT_TopologyDescription_Create_Args* args) {
+  return new PJRT_Error{absl::UnimplementedError(
+      "Topology not supported for client compilation.")};
+}
+
+}  // namespace mlir::stablehlo
+
+const PJRT_Api* GetPjrtApi() {
+  // printf("C++ Calling GetPjrtApi");
+  static PJRT_Layouts_Extension layouts_extension =
+      pjrt::CreateLayoutsExtension(nullptr);
+
+  static const PJRT_Api pjrt_api = pjrt::CreatePjrtApi(
+      mlir::stablehlo::PJRT_StablehloMlxClient_Create,
+      mlir::stablehlo::PJRT_StablehloMlxExecuteContext_Create,
+      mlir::stablehlo::PJRT_StablehloMlxDeviceTopology_Create,
+      pjrt::PJRT_Plugin_Initialize_NoOp,
+      reinterpret_cast<PJRT_Extension_Base*>(&layouts_extension),
+      pjrt::PJRT_Plugin_Attributes_Xla);
+
+  // printf("stablehlo_mlx client called GetPjrtApi\n");
+  return &pjrt_api;
+}
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_c_pjrt.h b/xla/pjrt/plugin/mlx/client_c_pjrt.h
new file mode 100644
index 0000000000..cc56626953
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_c_pjrt.h
@@ -0,0 +1,24 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_C_PJRT_H_
+#define XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_C_PJRT_H_
+
+#include "xla/pjrt/c/pjrt_c_api.h"
+
+extern "C" {
+
+// Does not pass ownership of returned PJRT_Api* to caller.
+const PJRT_Api* GetPjrtApi();
+}
+
+#endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_C_PJRT_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_cpp_pjrt.cc b/xla/pjrt/plugin/mlx/client_cpp_pjrt.cc
new file mode 100644
index 0000000000..ff20440d5b
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_cpp_pjrt.cc
@@ -0,0 +1,294 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "xla/pjrt/plugin/mlx/client_cpp_pjrt.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <memory>
+#include <vector>
+
+#include "absl/status/statusor.h"
+#include "absl/strings/str_format.h"
+#include "absl/strings/string_view.h"
+#include "absl/types/span.h"
+#include "xla/literal.h"
+#include "xla/pjrt/host_memory_spaces.h"
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/pjrt_common.h"
+#include "xla/pjrt/pjrt_compiler.h"
+#include "xla/pjrt/plugin/mlx/buffer.h"
+#include "xla/pjrt/plugin/mlx/device.h"
+#include "xla/pjrt/plugin/mlx/executable.h"
+#include "xla/pjrt/plugin/mlx/logging.h"
+#include "xla/shape_util.h"
+#include "xla/util.h"
+#include "tsl/platform/fingerprint.h"
+
+#define UNIMPLEMENTED(name) \
+  xla::Unimplemented("MlirPjrtBuffer::" #name " is not implemented")
+
+namespace mlir::stablehlo {
+
+const xla::PjRtPlatformId kStablehloMlxBackendId =
+    tsl::Fingerprint64(kStablehloMlxBackendName);
+
+class StablehloMlxPjrtClient : public xla::PjRtClient {
+ public:
+  StablehloMlxPjrtClient()
+      : xla::PjRtClient(),
+        owned_devices_(),
+        devices_(),
+        owned_memory_space_(),
+        memory_space_(nullptr) {
+    // Init device and memory space.
+    // TRACE_ME_MEMBER;
+    owned_devices_.push_back(GetStablehloMlxDevice(this));
+    devices_.push_back(owned_devices_.back().get());
+    owned_memory_space_ = std::make_unique<xla::UnpinnedHostMemorySpace>(
+        /*id=*/0, devices_.front());
+    memory_space_ = owned_memory_space_.get();
+    AttachStablehloMlxMemorySpace(devices_.front(), memory_space_);
+  }
+
+  ~StablehloMlxPjrtClient() override {};
+
+  absl::string_view platform_name() const override {
+    // TRACE_ME_MEMBER;
+    return kStablehloMlxBackendName;
+  }
+  int process_index() const override {
+    // TRACE_ME_MEMBER;
+    return 0;
+  }
+
+  int device_count() const override {
+    // TRACE_ME_MEMBER;
+    return devices_.size();
+  }
+
+  int addressable_device_count() const override {
+    // TRACE_ME_MEMBER;
+    return devices_.size();
+  }
+
+  absl::Span<xla::PjRtDevice* const> devices() const override {
+    // TRACE_ME_MEMBER;
+    return devices_;
+  }
+  absl::Span<xla::PjRtDevice* const> addressable_devices() const override {
+    // TRACE_ME_MEMBER;
+    return devices_;
+  }
+
+  absl::Span<xla::PjRtMemorySpace* const> memory_spaces() const override {
+    // TRACE_ME_MEMBER;
+    return absl::MakeSpan(&memory_space_, 1);
+  }
+
+  // Return an ID that identifies the platform via tsl fingerprint.
+  xla::PjRtPlatformId platform_id() const override {
+    // TRACE_ME_MEMBER;
+    return kStablehloMlxBackendId;
+  }
+
+  // Returns a string containing human-readable, platform-specific version
+  // info (e.g. the CUDA version on GPU or libtpu version on Cloud TPU).
+  absl::string_view platform_version() const override {
+    // TRACE_ME_MEMBER;
+    return "StableHLO MLX v0.1";
+  }
+
+  /////////////
+  // Device
+  /////////////
+
+  // Lookup any PjRtDevice for a given PjRtDevice::id().
+  // TODO: Should this be a base class? I.e. why doesn't the base client have
+  // a vector a device pointers?
+  absl::StatusOr<xla::PjRtDevice*> LookupDevice(
+      xla::PjRtGlobalDeviceId global_device_id) const override {
+    // TRACE_ME_MEMBER;
+    for (auto device : devices_) {
+      if (device->global_device_id() == global_device_id) {
+        return device;
+      }
+    }
+    // TODO: This error should be a base class method since its used in tests.
+    return xla::InvalidArgument("No matching device found for device_id %d",
+                                global_device_id.value());
+  }
+
+  absl::StatusOr<xla::PjRtDevice*> LookupAddressableDevice(
+      xla::PjRtLocalDeviceId local_device_id) const override {
+    // TRACE_ME_MEMBER;
+
+    for (auto* device : addressable_devices()) {
+      if (local_device_id == device->local_device_id()) {
+        return device;
+      }
+    }
+    return xla::InvalidArgument(
+        "No matching device found for local_device_id %d",
+        local_device_id.value());
+  }
+
+  absl::StatusOr<xla::DeviceAssignment> GetDefaultDeviceAssignment(
+      int num_replicas, int num_partitions) const override {
+    // TRACE_ME_MEMBER;
+    xla::DeviceAssignment assignment(num_replicas, num_partitions);
+    for (int64_t i = 0; i < num_replicas; ++i) {
+      for (int64_t j = 0; j < num_partitions; ++j) {
+        auto idx = (i + (j * num_replicas)) % devices_.size();
+        assignment(i, j) = devices_[idx]->global_device_id().value();
+      }
+    }
+    return assignment;
+  }
+
+  /////////////////
+  // Buffer methods
+  /////////////////
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CreateErrorBuffer(
+      absl::Status error, const xla::Shape& shape,
+      xla::PjRtDevice* device) override {
+    // Prefer memory space implementation, device holding buffer is
+    // deprecated.
+    return CreateErrorBuffer(error, shape,
+                             device->default_memory_space().value_or(nullptr));
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CreateErrorBuffer(
+      absl::Status error, const xla::Shape& shape,
+      xla::PjRtMemorySpace* memory) override {
+    return UNIMPLEMENTED(CreateErrorBuffer);
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> CreateUninitializedBuffer(
+      const xla::Shape& shape, xla::PjRtDevice* device) override {
+    // TRACE_ME_MEMBER;
+    return CreateMlirBufferUninitizlied(
+        shape, device->default_memory_space().value_or(nullptr));
+  }
+
+  absl::StatusOr<std::unique_ptr<PjRtClient::AsyncHostToDeviceTransferManager>>
+  CreateBuffersForAsyncHostToDevice(absl::Span<const xla::Shape> shapes,
+                                    xla::PjRtDevice* device) override {
+    // TRACE_ME_MEMBER;
+    return CreateBuffersForAsyncHostToDevice(
+        shapes, device->default_memory_space().value_or(nullptr));
+  }
+
+  absl::StatusOr<std::unique_ptr<PjRtClient::AsyncHostToDeviceTransferManager>>
+  CreateBuffersForAsyncHostToDevice(
+      absl::Span<const xla::Shape> shapes,
+      xla::PjRtMemorySpace* memory_space) override {
+    // TRACE_ME_MEMBER;
+    return UNIMPLEMENTED(CreateBuffersForAsyncHostToDevice);
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostBuffer(
+      const void* data, xla::PrimitiveType type, absl::Span<int64_t const> dims,
+      std::optional<absl::Span<int64_t const>> byte_strides,
+      HostBufferSemantics host_buffer_semantics,
+      absl::AnyInvocable<void() &&> on_done_with_host_buffer,
+      xla::PjRtDevice* device) override {
+    // TRACE_ME_MEMBER;
+    return BufferFromHostBuffer(
+        data, type, dims, byte_strides, host_buffer_semantics,
+        std::move(on_done_with_host_buffer),
+        device->default_memory_space().value_or(nullptr), nullptr);
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostBuffer(
+      const void* data, xla::PrimitiveType type, absl::Span<int64_t const> dims,
+      std::optional<absl::Span<int64_t const>> byte_strides,
+      HostBufferSemantics host_buffer_semantics,
+      absl::AnyInvocable<void() &&> on_done_with_host_buffer,
+      xla::PjRtDevice* device, const xla::Layout* device_layout) override {
+    // TRACE_ME_MEMBER;
+    return BufferFromHostBuffer(
+        data, type, dims, byte_strides, host_buffer_semantics,
+        std::move(on_done_with_host_buffer),
+        device->default_memory_space().value_or(nullptr), device_layout);
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostBuffer(
+      const void* data, xla::PrimitiveType type, absl::Span<int64_t const> dims,
+      std::optional<absl::Span<int64_t const>> byte_strides,
+      HostBufferSemantics host_buffer_semantics,
+      absl::AnyInvocable<void() &&> on_done_with_host_buffer,
+      xla::PjRtMemorySpace* memory_space,
+      const xla::Layout* device_layout) override {
+    // TRACE_ME_MEMBER;
+    // Buffer to Literal
+    auto shape = xla::ShapeUtil::MakeShape(type, dims);
+    auto literal =
+        xla::BorrowingLiteral(reinterpret_cast<const char*>(data), shape);
+    auto buffer = CreateMlirBufferFromLiteral(literal, memory_space);
+    if (on_done_with_host_buffer) {
+      // If host is awaiting the result, must call this function.
+      std::move(on_done_with_host_buffer)();
+      on_done_with_host_buffer = nullptr;
+    }
+    return buffer;
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostLiteral(
+      const xla::LiteralSlice& literal, xla::PjRtDevice* device) override {
+    // TRACE_ME_MEMBER;
+    return CreateMlirBufferFromLiteral(
+        literal, device->default_memory_space().value_or(nullptr));
+  }
+
+  absl::StatusOr<std::unique_ptr<xla::PjRtBuffer>> BufferFromHostLiteral(
+      const xla::LiteralSlice& literal,
+      xla::PjRtMemorySpace* memory_space) override {
+    // TRACE_ME_MEMBER;
+    return CreateMlirBufferFromLiteral(literal, memory_space);
+  }
+
+  ///////////
+  // Compile
+  ///////////
+  absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> Compile(
+      mlir::ModuleOp module, xla::CompileOptions options) override {
+    // TRACE_ME_MEMBER;
+    return mlir::stablehlo::StablehloMlxCompile(
+        module, GetDefaultDeviceAssignment(1, devices_.size()).value(), this);
+  }
+
+  // Compile `computation` with given `options`.
+  absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> Compile(
+      const xla::XlaComputation& computation,
+      xla::CompileOptions options) override {
+    // TRACE_ME_MEMBER;
+    return mlir::stablehlo::StablehloMlxCompile(
+        computation.proto(),
+        GetDefaultDeviceAssignment(1, devices_.size()).value(), this);
+  }
+
+ private:
+  std::vector<std::unique_ptr<xla::PjRtDevice>> owned_devices_;
+  std::vector<xla::PjRtDevice*> devices_;
+  std::unique_ptr<xla::PjRtMemorySpace> owned_memory_space_;
+  xla::PjRtMemorySpace* memory_space_;
+};  // end class
+
+std::unique_ptr<xla::PjRtClient> CreateStablehloMlxPjrtClient() {
+  SetupLogLevelFromEnv();
+  return std::make_unique<StablehloMlxPjrtClient>();
+}
+
+}  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/client_cpp_pjrt.h b/xla/pjrt/plugin/mlx/client_cpp_pjrt.h
new file mode 100644
index 0000000000..8c90942f0c
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/client_cpp_pjrt.h
@@ -0,0 +1,30 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_CPP_PJRT_H_
+#define XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_CPP_PJRT_H_
+
+#include <memory>
+
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/pjrt_compiler.h"
+
+namespace mlir::stablehlo {
+
+inline constexpr char kStablehloMlxBackendName[] = "stablehlo_mlx";
+extern const xla::PjRtPlatformId kStablehloMlxBackendId;
+
+std::unique_ptr<xla::PjRtClient> CreateStablehloMlxPjrtClient();
+
+}  // namespace mlir::stablehlo
+
+#endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_CLIENT_CPP_PJRT_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/device.cc b/xla/pjrt/plugin/mlx/device.cc
new file mode 100644
index 0000000000..6984da5b7f
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/device.cc
@@ -0,0 +1,213 @@
+/* Copyright 2024 The OpenXLA Authors.
+
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "mlx/mlx.h"
+
+#include "xla/pjrt/plugin/mlx/device.h"
+
+#include "absl/status/statusor.h"
+#include "absl/strings/str_format.h"
+#include "absl/strings/string_view.h"
+#include "absl/types/span.h"
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/pjrt_common.h"
+#include "xla/pjrt/pjrt_compiler.h"
+#include "xla/pjrt/pjrt_device_description.h"
+#include "xla/pjrt/plugin/mlx/logging.h"
+#include "xla/util.h"
+
+#define UNIMPLEMENTED(name) \
+  xla::Unimplemented("StablehloMlxDevice::" #name " is not implemented")
+
+namespace mlir::stablehlo {
+
+using xla::LiteralSlice;
+using xla::MutableBorrowingLiteral;
+using xla::PjRtClient;
+using xla::PjRtDevice;
+using xla::PjRtDeviceAttribute;
+using xla::PjRtDeviceDescription;
+using xla::PjRtGlobalDeviceId;
+using xla::PjRtLocalDeviceId;
+using xla::PjRtLocalHardwareId;
+using xla::PjRtMemorySpace;
+using xla::ScopedAsyncTrackingEvent;
+using xla::Unimplemented;
+
+namespace mx = mlx::core;
+
+inline std::string mlxDeviceToString(const mx::Device& device) {
+  std::ostringstream os;
+  os << device;
+  return os.str();
+}
+// Devices need a device description.
+class StablehloMlxDeviceDescription final : public PjRtDeviceDescription {
+ public:
+  explicit StablehloMlxDeviceDescription(int process_id, int local_device_id)
+      : id_(local_device_id),
+        process_index_(process_id),
+        local_hardware_id_(local_device_id),
+        debug_string_(mlxDeviceToString(mx::default_device())),
+        to_string_(absl::StrFormat("%s(id=%d,pid=%d)", debug_string_,
+                                   id_.value(), process_index_)) {
+    // TRACE_ME_MEMBER;
+  }
+
+  int id() const override {
+    // TRACE_ME_MEMBER;
+    return id_.value();
+  }
+  int process_index() const override {
+    // TRACE_ME_MEMBER;
+    return process_index_;
+  }
+  int local_hardware_id() const {
+    // TRACE_ME_MEMBER;
+    return local_hardware_id_;
+  }
+
+  absl::string_view device_kind() const override {
+    // TRACE_ME_MEMBER;
+    return DebugString();
+  }
+
+  absl::string_view DebugString() const override {
+    // TRACE_ME_MEMBER;
+    return debug_string_;
+  }
+
+  absl::string_view ToString() const override {
+    // TRACE_ME_MEMBER;
+    return to_string_;
+  }
+
+  const absl::flat_hash_map<std::string, PjRtDeviceAttribute>& Attributes()
+      const override {
+    // TRACE_ME_MEMBER;
+    return attributes_;
+  }
+
+ private:
+  PjRtGlobalDeviceId id_;
+  int process_index_;
+  int local_hardware_id_;
+  std::string debug_string_;
+  std::string to_string_;
+  absl::flat_hash_map<std::string, PjRtDeviceAttribute> attributes_ = {};
+};
+
+// Clients need devices, and clients own the devices.
+class StablehloMlxDevice : public PjRtDevice {
+ public:
+  explicit StablehloMlxDevice(PjRtClient* client)
+      : PjRtDevice(), client_(client), description_(0, 0) {
+    // TRACE_ME_MEMBER;
+  }
+
+  absl::string_view DebugString() const override {
+    // TRACE_ME_MEMBER;
+    return "StablehloMlxDevice";
+  }
+
+  PjRtLocalDeviceId local_device_id() const override {
+    // TRACE_ME_MEMBER;
+    return PjRtLocalDeviceId(local_hardware_id().value());
+  }
+
+  PjRtLocalHardwareId local_hardware_id() const override {
+    // TRACE_ME_MEMBER;
+    return PjRtLocalHardwareId(description_.local_hardware_id());
+  }
+
+  PjRtClient* client() const override {
+    // TRACE_ME_MEMBER;
+    return client_;
+  }
+
+  bool IsAddressable() const override {
+    // TRACE_ME_MEMBER;
+    return process_index() == client()->process_index();
+  }
+
+  absl::Status TransferToInfeed(const LiteralSlice& literal) override {
+    // TRACE_ME_MEMBER;
+    return UNIMPLEMENTED(TransferToInfeed);
+  }
+
+  absl::Status TransferFromOutfeed(MutableBorrowingLiteral literal) override {
+    // TRACE_ME_MEMBER;
+    return UNIMPLEMENTED(TransferFromOutfeed);
+  }
+
+  void AttachDefaultMemorySpace(PjRtMemorySpace* memory_space) {
+    // TRACE_ME_MEMBER;
+    memory_space_ = memory_space;
+  }
+
+  absl::Span<PjRtMemorySpace* const> memory_spaces() const override {
+    // TRACE_ME_MEMBER;
+    return absl::MakeSpan(&memory_space_, 1);
+  }
+
+  absl::StatusOr<PjRtMemorySpace*> default_memory_space() const override {
+    // TRACE_ME_MEMBER;
+    if (!memory_space_)
+      return absl::InternalError("Plugin memory space unset.");
+
+    return memory_space_;
+  }
+
+  std::unique_ptr<ScopedAsyncTrackingEvent> CreateAsyncTrackingEvent(
+      absl::string_view description) const override {
+    // TRACE_ME_MEMBER;
+    LOG(FATAL) << "Plugin does not implement CreateAsyncTrackingEvent.";
+    return nullptr;
+  }
+
+  const PjRtDeviceDescription& description() const override {
+    // TRACE_ME_MEMBER;
+    return description_;
+  }
+
+ private:
+  PjRtClient* client_;
+  PjRtMemorySpace* memory_space_;  // unpinned memory owned by client
+  StablehloMlxDeviceDescription description_;
+};
+
+// Device Description
+std::unique_ptr<PjRtDeviceDescription> GetStablehloMlxDeviceDescription(
+    int process_id, int local_device_id) {
+  return std::make_unique<StablehloMlxDeviceDescription>(process_id,
+                                                         local_device_id);
+}
+
+// Mlx Device
+std::unique_ptr<PjRtDevice> GetStablehloMlxDevice(PjRtClient* client) {
+  return std::make_unique<StablehloMlxDevice>(client);
+}
+
+void AttachStablehloMlxMemorySpace(PjRtDevice* device,
+                                   PjRtMemorySpace* memory_space) {
+  auto stablehlo_device = dynamic_cast<StablehloMlxDevice*>(device);
+  if (stablehlo_device == nullptr) {
+    LOG(FATAL) << "Plugin cannot attach memory space to device of kind "
+               << device->device_kind();
+    return;
+  }
+  stablehlo_device->AttachDefaultMemorySpace(memory_space);
+}
+
+}  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/device.h b/xla/pjrt/plugin/mlx/device.h
new file mode 100644
index 0000000000..ef42968a3a
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/device.h
@@ -0,0 +1,36 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_DEVICE_H_
+#define XLA_PJRT_PLUGIN_STABLEHLO_MLX_DEVICE_H_
+
+#include <memory>
+
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/pjrt_compiler.h"
+#include "xla/pjrt/pjrt_device_description.h"
+
+namespace mlir::stablehlo {
+
+// Device Description
+std::unique_ptr<xla::PjRtDeviceDescription> GetStablehloMlxDeviceDescription(
+    int process_id, int local_device_id);
+
+// MLX Device
+std::unique_ptr<xla::PjRtDevice> GetStablehloMlxDevice(xla::PjRtClient* client);
+
+void AttachStablehloMlxMemorySpace(xla::PjRtDevice* device,
+                                   xla::PjRtMemorySpace* memory_space);
+
+}  // namespace mlir::stablehlo
+
+#endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_DEVICE_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/executable.cc b/xla/pjrt/plugin/mlx/executable.cc
new file mode 100644
index 0000000000..25bae8cfcd
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/executable.cc
@@ -0,0 +1,1035 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "xla/pjrt/plugin/mlx/executable.h"
+
+#include <memory>
+#include <optional>
+#include <utility>
+#include <unordered_map>
+#include <vector>
+
+// TODO(@cryptodeal): might need to update `BUILD`
+#include "mlir/IR/Visitors.h"
+#include "llvm/ADT/TypeSwitch.h"
+
+#include "mlx/mlx.h"
+#include "absl/log/log.h"
+#include "absl/status/status.h"
+#include "absl/status/statusor.h"
+#include "mlir/Bytecode/BytecodeWriter.h"
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/IR/AsmState.h"
+#include "mlir/IR/BuiltinAttributes.h"
+#include "mlir/IR/MLIRContext.h"
+#include "mlir/IR/Operation.h"
+#include "mlir/IR/OwningOpRef.h"
+#include "mlir/Interfaces/DataLayoutInterfaces.h"
+#include "mlir/Pass/PassManager.h"
+#include "mlir/Support/LLVM.h"
+#include "stablehlo/reference/Api.h"
+#include "stablehlo/transforms/Passes.h"
+#include "xla/hlo/translate/stablehlo.h"
+#include "xla/mlir/utils/error_util.h"
+#include "xla/mlir_hlo/mhlo/transforms/passes.h"
+#include "xla/mlir_hlo/stablehlo_ext/transforms/passes.h"
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/pjrt/pjrt_executable.h"
+#include "xla/pjrt/pjrt_future.h"
+#include "xla/pjrt/plugin/mlx/buffer.h"
+#include "xla/pjrt/plugin/mlx/logging.h"
+#include "xla/service/computation_placer.h"
+#include "tsl/platform/statusor.h"
+
+#define DEBUG_TYPE "stablehlo-pjrt"
+
+namespace mx = mlx::core;
+
+namespace mlir::stablehlo {
+
+#define UNIMPLEMENTED(name) \
+  xla::Unimplemented("MlirPjrtBuffer::" #name " is not implemented")
+
+using xla::DeviceAssignment;
+using xla::PjRtBuffer;
+using xla::PjRtClient;
+using xla::PjRtDevice;
+using xla::PjRtFuture;
+using xla::PjRtLoadedExecutable;
+using xla::PjRtMemorySpace;
+
+mlir::OwningOpRef<ModuleOp> cloneIntoContext(ModuleOp module,
+                                             MLIRContext& context) {
+  // Clone the module into the context. MHLO->StableHLO just in case.
+  PassManager pm(module->getContext());
+  pm.addPass(mhlo::createHloLegalizeToStablehloPass());
+  if (failed(pm.run(module))) {
+    LOG(ERROR) << "Failed to convert MHLO to StableHLO";
+    return nullptr;
+  }
+
+  std::string bytecode;
+  llvm::raw_string_ostream os(bytecode);
+  mlir::BytecodeWriterConfig config;
+  mlir::OwningOpRef<mlir::ModuleOp> cloned = module.clone();
+  if (mlir::failed(mlir::writeBytecodeToFile(*cloned, os, config))) {
+    LOG(ERROR) << "Failed to write bytecode to string\n";
+    return nullptr;
+  }
+  return *parseStablehloModule(bytecode, context);
+}
+
+LogicalResult decomposeChloToStablehlo(ModuleOp module) {
+  PassManager pm(module->getContext());
+  stablehlo_ext::createChloLegalizeToStablehloPipeline(pm);
+  if (failed(pm.run(module))) {
+    return module->emitError() << "Failed to recompose CHLO";
+  }
+  return success();
+}
+
+std::optional<Operation*> getUnsupportedOp(ModuleOp module) {
+  std::optional<Operation*> unsupported_op(std::nullopt);
+  module.walk([&unsupported_op](Operation* op) {
+    auto cc = llvm::dyn_cast<stablehlo::CustomCallOp>(op);
+    if (cc) {
+      unsupported_op = op;
+      return WalkResult::interrupt();
+    }
+    return WalkResult::advance();
+  });
+  return unsupported_op;
+}
+
+LogicalResult runHardwareIndependentOptimizations(ModuleOp module) {
+  PassManager pm(module->getContext());
+  pm.addNestedPass<func::FuncOp>(
+      stablehlo::createStablehloAggressiveFolderPass());
+  pm.addNestedPass<func::FuncOp>(
+      stablehlo::createStablehloAggressiveSimplificationPass());
+  if (failed(pm.run(module))) {
+    return module->emitError()
+           << "Failed to run hardware independent optimizations";
+  }
+  return success();
+}
+
+mx::Dtype dtypeFromType(const mlir::Type& type) {
+  return llvm::TypeSwitch<Type, mx::Dtype>(type)
+      .Case<IntegerType>([](IntegerType t) {
+        switch (t.getWidth()) {
+          case 1:
+            return mx::bool_;
+          case 8:
+            return t.isSignless() ? mx::int8 : mx::uint8;
+          case 16:
+            return t.isSignless() ? mx::int16 : mx::uint16;
+          case 32:
+            return t.isSignless() ? mx::int32 : mx::uint32;
+          default:
+            return t.isSignless() ? mx::int64 : mx::uint64;
+        }
+      })
+      .Case<BFloat16Type>([](BFloat16Type t) { return mx::bfloat16; })
+      .Case<Float16Type>([](Float16Type t) { return mx::float16; })
+      .Case<ComplexType>([](ComplexType t) { return mx::complex64; })
+      // default float32
+      .Default([](Type) { return mx::float32; });
+}
+
+std::vector<mx::array> getArgArrays(
+    Operation* operation,
+    const std::unordered_map<Operation*, mx::array>& transient_buffers,
+    const std::vector<mx::array>& block_arguments) {
+  std::vector<mx::array> args;
+  for (Value operand : operation->getOperands()) {
+    if (auto defining_op = operand.getDefiningOp()) {
+      // arg was created as a result of previously executed operation
+      // push array to args if found, else return early
+      if (auto search = transient_buffers.find(defining_op);
+          search != transient_buffers.end())
+        args.push_back(search->second);
+      else
+        return args;
+    } else {
+      auto block_arg = operand.cast<BlockArgument>();
+      auto arg_number = block_arg.getArgNumber();
+      // if block arguments contains the arg at the given index,
+      // push to args; else return early
+      if (block_arguments.size() > arg_number)
+        args.push_back(block_arguments[arg_number]);
+      else
+        return args;
+    }
+  }
+  return args;
+}
+
+std::vector<int32_t> getMlxShape(const mlir::ShapedType& dense_elements_type) {
+  std::vector<int32_t> shape;
+  if (dense_elements_type.hasRank()) {
+    for (auto dim : dense_elements_type.getShape()) {
+      shape.push_back(static_cast<int32_t>(dim));
+    }
+  }
+  return shape;
+}
+
+template <typename T>
+mx::array denseElementsArray(const char* buffer,
+                             const std::vector<int32_t>& shape, bool is_splat) {
+  return is_splat ? mx::full<T>(shape, reinterpret_cast<const T*>(buffer)[0])
+                  : mx::array(reinterpret_cast<const T*>(buffer), shape);
+}
+
+mx::array getDenseElementsArray(const mlir::DenseElementsAttr& attr) {
+  auto attr_type = attr.getType();
+  // convert to mlx shape
+  std::vector<int32_t> attr_shape = getMlxShape(attr_type);
+  auto attr_raw_data = attr.getRawData();
+  const char* buffer_ref = attr_raw_data.data();
+  auto element_type = attr_type.getElementType();
+
+  // TODO(@cryptodeal): `Compile` must verify there are no unsupported types.
+
+  return llvm::TypeSwitch<Type, mx::array>(element_type)
+      // handle integer types
+      .Case<IntegerType>([&buffer_ref, &attr, &attr_shape](auto type) {
+        switch (type.getWidth()) {
+          // handle bool
+          case 1:
+            return denseElementsArray<bool>(buffer_ref, attr_shape,
+                                            attr.isSplat());
+          case 8:
+            return type.isSignless()
+                       ? denseElementsArray<int8_t>(buffer_ref, attr_shape,
+                                                    attr.isSplat())
+                       : denseElementsArray<uint8_t>(buffer_ref, attr_shape,
+                                                     attr.isSplat());
+          case 16:
+            return type.isSignless()
+                       ? denseElementsArray<int16_t>(buffer_ref, attr_shape,
+                                                     attr.isSplat())
+                       : denseElementsArray<uint16_t>(buffer_ref, attr_shape,
+                                                      attr.isSplat());
+          case 32:
+            return type.isSignless()
+                       ? denseElementsArray<int32_t>(buffer_ref, attr_shape,
+                                                     attr.isSplat())
+                       : denseElementsArray<uint32_t>(buffer_ref, attr_shape,
+                                                      attr.isSplat());
+          // default is 64 bit width
+          default:
+            return type.isSignless()
+                       ? denseElementsArray<int64_t>(buffer_ref, attr_shape,
+                                                     attr.isSplat())
+                       : denseElementsArray<uint64_t>(buffer_ref, attr_shape,
+                                                      attr.isSplat());
+        }
+      })
+      .Case<BFloat16Type>([&buffer_ref, &attr, &attr_shape](auto type) {
+        return denseElementsArray<mx::bfloat16_t>(buffer_ref, attr_shape,
+                                                  attr.isSplat());
+      })
+      .Case<Float16Type>([&buffer_ref, &attr, &attr_shape](auto type) {
+        return denseElementsArray<mx::float16_t>(buffer_ref, attr_shape,
+                                                 attr.isSplat());
+      })
+      .Case<ComplexType>([&buffer_ref, &attr, &attr_shape](auto type) {
+        return denseElementsArray<mx::complex64_t>(buffer_ref, attr_shape,
+                                                   attr.isSplat());
+      })
+      // Default is Float32Type
+      .Default([&buffer_ref, &attr, &attr_shape](auto type) {
+        return denseElementsArray<float>(buffer_ref, attr_shape,
+                                         attr.isSplat());
+      });
+}
+
+class MlirLoadedExecutable : public PjRtLoadedExecutable {
+ public:
+  MlirLoadedExecutable(ModuleOp module, DeviceAssignment assignment,
+                       absl::Span<PjRtDevice* const> devices,
+                       PjRtClient* client)
+      : PjRtLoadedExecutable(),
+        name_("MlirLoadedExecutable"),
+        assignment_(assignment),
+        devices_(client->devices()),
+        client_(client),
+        context_(),
+        module_(cloneIntoContext(module, context_)) {
+    // TRACE_ME_MEMBER;
+  }
+
+  static absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>> Compile(
+      ModuleOp module, DeviceAssignment assignment,
+      absl::Span<PjRtDevice* const> devices, PjRtClient* client) {
+    TRACE_ME;
+    mlir::BaseScopedDiagnosticHandler diagnostic_handler(module->getContext());
+    if (failed(decomposeChloToStablehlo(module))) {
+      return diagnostic_handler.ConsumeStatus();
+    }
+    if (auto unsupported_op = getUnsupportedOp(module)) {
+      LOG(ERROR) << "Unsupported op: " << ToString(*unsupported_op)
+                 << "\nFound in module: " << ToString(module);
+      return absl::UnimplementedError(
+          absl::StrCat("Unsupported op: ", ToString(*unsupported_op)));
+    }
+
+    // Simplify the graph using available HWI passes.
+    if (failed(runHardwareIndependentOptimizations(module))) {
+      return diagnostic_handler.ConsumeStatus();
+    }
+
+    auto executable = std::make_unique<MlirLoadedExecutable>(module, assignment,
+                                                             devices, client);
+
+    return executable;
+  }
+
+  PjRtClient* client() const override {
+    // TRACE_ME_MEMBER;
+    return client_;
+  }
+
+  const DeviceAssignment& device_assignment() const override {
+    // TRACE_ME_MEMBER;
+    return assignment_;
+  }
+
+  absl::Span<const PjRtLoadedExecutable::LogicalDeviceIds>
+  addressable_device_logical_ids() const override {
+    // TRACE_ME_MEMBER;
+    LOG_UNIMPLEMENTED(addressable_device_logical_ids);
+    return {};
+  }
+
+  absl::Span<PjRtDevice* const> addressable_devices() const override {
+    // TRACE_ME_MEMBER;
+    return devices_;
+  }
+
+  // Helper function to get default mem from device.
+  PjRtMemorySpace* get_default_memory_space() const {
+    // TRACE_ME_MEMBER;
+    return devices_[0]->default_memory_space().value_or(nullptr);
+  }
+
+  FailureOr<SmallVector<DenseElementsAttr>> evalModule(
+      ModuleOp& module, const SmallVector<mlir::DenseElementsAttr>& inputs) {
+    // TRACE_ME_MEMBER;
+    std::vector<mx::array> block_arguments;
+    for (auto input : inputs) {
+      block_arguments.push_back(getDenseElementsArray(input));
+    }
+
+    // TODO(@cryptodeal): make the module walk logic recursive to handle
+    // `func::FuncOp`, which contains nested a `mlir::Operation` tree
+    // that must be walked.
+
+    // Value is only set if all operations are executed successfully.
+    std::optional<mx::array> res;
+
+    // TODO(@cryptodeal): operations can return multiple results,
+    // will need to switch to something along the lines of
+    // std::unordered_map<Operation*, std::vector<mx::array>> transient_buffers;
+
+    // holds intermediary results of operation calls.
+    std::unordered_map<Operation*, mx::array> transient_buffers;
+    // walk the moud
+    module.walk([&block_arguments, &transient_buffers, &res](Operation* op) {
+      // get operands for each operation call
+      auto operands = getArgArrays(op, transient_buffers, block_arguments);
+
+      // if the number of operands does not match the expected number,
+      // interrupt walk and return early.
+      if (operands.size() != op->getNumOperands())
+        return WalkResult::interrupt();
+
+      // TODO(@cryptodeal): explore writing mlx extension that implements
+      // various missing ops
+
+      // switch on the operation type
+      return llvm::TypeSwitch<Operation*, WalkResult>(op)
+          // TODO(@cryptodeal): handle `func` namespace ops
+          .Case<func::ReturnOp>([&res, &operands](auto op) {
+            // set the result value and interrupt the walk.
+            res = operands[0];
+            return WalkResult::interrupt();
+          })
+
+          // Handle StableHLO nullary ops
+          .Case<stablehlo::ConstantOp>([&transient_buffers,
+                                        &operands](auto op) {
+            transient_buffers.insert(
+                {op, getDenseElementsArray(
+                         mlir::cast<mlir::DenseElementsAttr>(op.getValue()))});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::IotaOp>([&transient_buffers, &operands](auto op) {
+            auto result_type = op.getResult().getType();
+            std::vector<int32_t> shape =
+                getMlxShape(mlir::cast<ShapedType>(result_type));
+            auto iota_dimension = op.getIotaDimension();
+            std::vector<int32_t> dimensions;
+            for (auto i = 0; i < dimensions.size(); i++) {
+              dimensions.push_back(i != iota_dimension ? 1 : shape[i]);
+            }
+            transient_buffers.insert(
+                {op, mx::broadcast_to(
+                         mx::reshape(mx::arange(static_cast<double>(
+                                                    shape[iota_dimension]),
+                                                dtypeFromType(result_type)),
+                                     dimensions),
+                         shape)});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::DynamicIotaOp>([](auto op) {})
+          /*
+            .Case<stablehlo::CreateTokenOp>([](auto op) {})
+            Deprecated see:
+              https://github.com/openxla/stablehlo/issues/2340
+              https://github.com/openxla/stablehlo/pull/2283
+          */
+
+          // Handle StableHLO unary elementwise op
+          .Case<stablehlo::AbsOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::abs(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::CbrtOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::power(operands[0],
+                               mx::full<float>(operands[0].shape(), 1 / 3,
+                                               operands[0].dtype()))});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::CeilOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::ceil(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::CeilOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::ceil(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::ConvertOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op,
+                 mx::astype(operands[0],
+                            dtypeFromType(
+                                op.getResult().getType().getElementType()))});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::ClzOp>([](auto op) {})
+          .Case<stablehlo::CosineOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::cos(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::ExpOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::exp(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::Expm1Op>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::expm1(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::FloorOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::floor(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::ImagOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::imag(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::IsFiniteOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert({op, mx::isfinite(operands[0])});
+                return WalkResult::advance();
+              })
+          .Case<stablehlo::LogOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::log(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::Log1pOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::log1p(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::LogisticOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert({op, mx::sigmoid(operands[0])});
+                return WalkResult::advance();
+              })
+          .Case<stablehlo::NotOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::logical_not(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::NegOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::negative(operands[0])});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::PopulationCountOp>([](auto op) {})
+          .Case<stablehlo::RealOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::real(operands[0])});
+            return WalkResult::advance();
+          })
+          // `stablehlo::RoundOp` does not match with the mlx metal
+          // implementation .Case<stablehlo::RoundOp>([](auto op) {})
+          .Case<stablehlo::RoundNearestEvenOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert({op, mx::round(operands[0])});
+                return WalkResult::advance();
+              })
+          .Case<stablehlo::RsqrtOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::rsqrt(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::SignOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::sign(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::SineOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::sin(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::SqrtOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::sqrt(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::TanOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::tan(operands[0])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::TanhOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::tanh(operands[0])});
+            return WalkResult::advance();
+          })
+
+          // Handle StableHLO binary elementwise ops
+          .Case<stablehlo::AddOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::add(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::Atan2Op>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::arctan2(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          // TODO(@cryptodeal): implement complex op
+          // .Case<stablehlo::ComplexOp>([&transient_buffers, &operands](auto
+          // op) {
+          //   transient_buffers.insert(op, mx::complex(operands[0],
+          //   operands[1])); return WalkResult::advance();
+          // })
+          .Case<stablehlo::DivOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::divide(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::MaxOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::maximum(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::MinOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::minimum(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::MulOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::multiply(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::PowOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert({op, mx::power(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::RemOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::remainder(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::ShiftLeftOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert(
+                    {op, mx::left_shift(operands[0], operands[1])});
+                return WalkResult::advance();
+              })
+          // TODO(@cryptodeal): handle shift right (xla has 2 options)
+          // .Case<stablehlo::ShiftRightArithmeticOp>([&transient_buffers,
+          // &operands](auto op) {
+          //   transient_buffers.insert(op, mx::right_shift(operands[0],
+          //   operands[1])); return WalkResult::advance();
+          // })
+          // .Case<stablehlo::ShiftRightLogicalOp>([&transient_buffers,
+          // &operands](auto op) {
+          //   transient_buffers.insert(op, mx::right_shift(operands[0],
+          //   operands[1])); return WalkResult::advance();
+          // })
+          .Case<stablehlo::SubtractOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert(
+                    {op, mx::subtract(operands[0], operands[1])});
+                return WalkResult::advance();
+              })
+          // Handle StableHLO binary logical elementwise ops
+          .Case<stablehlo::AndOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::logical_and(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::OrOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::logical_or(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::XorOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::bitwise_xor(operands[0], operands[1])});
+            return WalkResult::advance();
+          })
+
+          // TODO(@cryptodeal): probably don't need to implement all
+          // of the following ops, but listing all for reference
+
+          // Handle StableHLO communication ops
+          // .Case<stablehlo::InfeedOp>([](auto op) {})
+          // .Case<stablehlo::OutfeedOp>([](auto op) {})
+          // .Case<stablehlo::SendOp>([](auto op) {})
+          // .Case<stablehlo::RecvOp>([](auto op) {})
+
+          // Handle StableHLO parallelism related ops
+          // .Case<stablehlo::ReplicaIdOp>([](auto op) {})
+          // .Case<stablehlo::PartitionIdOp>([](auto op) {})
+          // .Case<stablehlo::PartitionIdOp>([](auto op) {})
+
+          // Handle StableHLO control flow ops
+          // .Case<stablehlo::AfterAllOp>([](auto op) {})
+          // .Case<stablehlo::IfOp>([](auto op) {})
+          // .Case<stablehlo::CaseOp>([](auto op) {})
+          // .Case<stablehlo::WhileOp>([](auto op) {})
+          // .Case<stablehlo::AllGatherOp>([](auto op) {})
+          // .Case<stablehlo::AllReduceOp>([](auto op) {})
+          // .Case<stablehlo::ReduceScatterOp>([](auto op) {})
+          // .Case<stablehlo::AllToAllOp>([](auto op) {})
+          // .Case<stablehlo::ReduceOp>([](auto op) {})
+          // .Case<stablehlo::GetTupleElementOp>([](auto op) {})
+          // .Case<stablehlo::TupleOp>([](auto op) {})
+          .Case<stablehlo::CompareOp>([&transient_buffers, &operands](auto op) {
+            auto comp_dir = op.getComparisonDirection();
+            switch (op.getComparisonDirection()) {
+              case ComparisonDirection::NE:
+                transient_buffers.insert(
+                    {op, mx::not_equal(operands[0], operands[1])});
+                break;
+              case ComparisonDirection::GE:
+                transient_buffers.insert(
+                    {op, mx::greater_equal(operands[0], operands[1])});
+                break;
+              case ComparisonDirection::GT:
+                transient_buffers.insert(
+                    {op, mx::greater(operands[0], operands[1])});
+                break;
+              case ComparisonDirection::LE:
+                transient_buffers.insert(
+                    {op, mx::less_equal(operands[0], operands[1])});
+                break;
+              case ComparisonDirection::LT:
+                transient_buffers.insert(
+                    {op, mx::less(operands[0], operands[1])});
+                break;
+              default:
+                transient_buffers.insert(
+                    {op, mx::equal(operands[0], operands[1])});
+            }
+            return WalkResult::advance();
+          })
+
+          // Handle StableHLO Slice ops
+          .Case<stablehlo::SliceOp>([&transient_buffers, &operands](auto op) {
+            auto op_start_indices = op.getStartIndices();
+            auto op_limit_indices = op.getLimitIndices();
+            auto op_strides = op.getStrides();
+            std::vector<int32_t> start_indices;
+            std::vector<int32_t> limit_indices;
+            std::vector<int32_t> strides;
+            for (auto i = 0; i < op_start_indices.size(); i++) {
+              start_indices.push_back(
+                  static_cast<int32_t>(op_start_indices[i]));
+              limit_indices.push_back(
+                  static_cast<int32_t>(op_limit_indices[i]));
+              strides.push_back(static_cast<int32_t>(op_strides[i]));
+            }
+
+            transient_buffers.insert({op, mx::slice(operands[0], start_indices,
+                                                    limit_indices, strides)});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::DynamicSliceOp>([](auto op) {})
+          // .Case<stablehlo::DynamicUpdateSliceOp>([](auto op) {})
+
+          // Handle StableHLO Other ops
+          // .Case<stablehlo::BatchNormGradOp>([](auto op) {})
+          // .Case<stablehlo::BatchNormInferenceOp>([](auto op) {})
+          // .Case<stablehlo::BatchNormTrainingOp>([](auto op) {})
+          // .Case<stablehlo::BitcastConvertOp>([](auto op) {})
+          /*
+            .Case<stablehlo::BroadcastOp>([](auto op) {})
+            Deprecated see:
+              https://github.com/openxla/stablehlo/issues/2340
+              https://github.com/openxla/stablehlo/pull/2283
+          */
+          .Case<stablehlo::BroadcastInDimOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert(
+                    {op, mx::broadcast_to(operands[0],
+                                          getMlxShape(mlir::cast<ShapedType>(
+                                              op.getResult().getType())))});
+                return WalkResult::advance();
+              })
+          // .Case<stablehlo::DynamicBroadcastInDimOp>([](auto op) {})
+          // .Case<stablehlo::CholeskyOp>([](auto op) {})
+          .Case<stablehlo::ClampOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op, mx::clip(operands[1], operands[0], operands[2])});
+            return WalkResult::advance();
+          })
+          .Case<stablehlo::ConcatenateOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert(
+                    {op, mx::concatenate(operands, op.getDimension())});
+                return WalkResult::advance();
+              })
+          // .Case<stablehlo::CollectiveBroadcastOp>([](auto op) {})
+          // .Case<stablehlo::CollectivePermuteOp>([](auto op) {})
+          // .Case<stablehlo::CompositeOp>([](auto op) {})
+          // .Case<stablehlo::ConvolutionOp>([](auto op) {})
+          // .Case<stablehlo::CrossReplicaSumOp>([](auto op) {})
+          // .Case<stablehlo::CustomCallOp>([](auto op) {})
+          /*
+            .Case<stablehlo::DotOp>([](auto op) {})
+            Deprecated see:
+              https://github.com/openxla/stablehlo/issues/2340
+              https://github.com/openxla/stablehlo/pull/2283
+          */
+          // TODO(@cryptodeal): need to figure out `DotGeneralOp` ->
+          // `mx::tensordot` .Case<stablehlo::DotGeneralOp>([&transient_buffers,
+          //                                 &operands](auto op) {
+          //   std::vector<int> lhs_batching_dims;
+          //   std::vector<int> rhs_batching_dims;
+          //   for (auto dim :
+          //        op.getDotDimensionNumbers().getLhsBatchingDimensions()) {
+          //     lhs_batching_dims.push_back(static_cast<int>(dim));
+          //   }
+          //   for (auto dim :
+          //        op.getDotDimensionNumbers().getRhsBatchingDimensions()) {
+          //     rhs_batching_dims.push_back(static_cast<int>(dim));
+          //   }
+          //   transient_buffers.insert(
+          //       op, mx::tensordot(operands[0], operands[1], {1, 2}, {1, 2}));
+          //   return WalkResult::advance();
+          // })
+          /*
+            .Case<stablehlo::EinsumOp>([](auto op) {})
+            .Case<stablehlo::UnaryEinsumOp>([](auto op) {})
+            Deprecated see:
+              https://github.com/openxla/stablehlo/issues/2340
+              https://github.com/openxla/stablehlo/pull/2283
+          */
+          // .Case<stablehlo::FftOp>([](auto op) {})
+          // .Case<stablehlo::GatherOp>([](auto op) {})
+          .Case<stablehlo::GetDimensionSizeOp>(
+              [&transient_buffers, &operands](auto op) {
+                transient_buffers.insert(
+                    {op, mx::array(operands[0].shape(op.getDimension()))});
+                return WalkResult::advance();
+              })
+          // .Case<stablehlo::MapOp>([](auto op) {})
+          .Case<stablehlo::ReshapeOp>([&transient_buffers, &operands](auto op) {
+            transient_buffers.insert(
+                {op,
+                 mx::reshape(operands[0], getMlxShape(mlir::cast<ShapedType>(
+                                              op.getResult().getType())))});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::DynamicReshapeOp>([](auto op) {})
+          // .Case<stablehlo::ScatterOp>([](auto op) {})
+          // .Case<stablehlo::SelectOp>([](auto op) {})
+          // .Case<stablehlo::SelectAndScatterOp>([](auto op) {})
+          // .Case<stablehlo::SetDimensionSizeOp>([](auto op) {})
+          // .Case<stablehlo::SortOp>([](auto op) {})
+          // .Case<stablehlo::ReverseOp>([](auto op) {})
+          // .Case<stablehlo::PadOp>([](auto op) {})
+          .Case<stablehlo::TransposeOp>([&transient_buffers,
+                                         &operands](auto op) {
+            std::vector<int> axes;
+            for (auto axis : op.getPermutation()) {
+              axes.push_back(static_cast<int>(axis));
+            }
+            transient_buffers.insert({op, mx::transpose(operands[0], axes)});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::TriangularSolveOp>([](auto op) {})
+          // .Case<stablehlo::ReduceWindowOp>([](auto op) {})
+          // .Case<stablehlo::ReturnOp>([](auto op) {})
+          // .Case<stablehlo::TorchIndexSelectOp>([](auto op) {})
+          // .Case<stablehlo::OptimizationBarrierOp>([](auto op) {})
+          // .Case<stablehlo::CrossReplicaSumOp>([](auto op) {})
+
+          // Handle StableHLO RNG ops
+          .Case<stablehlo::RngOp>([&transient_buffers, &operands](auto op) {
+            auto shape_buffer = operands[2].data<int64_t>();
+            std::vector<int32_t> shape;
+            for (auto i = 0; i < operands[2].size(); i++) {
+              shape.push_back(static_cast<int32_t>(shape_buffer[i]));
+            }
+            transient_buffers.insert(
+                {op,
+                 op.getRngDistribution() == RngDistribution::UNIFORM
+                     ? mx::random::uniform(operands[0], operands[1], shape,
+                                           operands[0].dtype())
+                     : mx::random::normal(
+                           shape, operands[0].dtype(),
+                           mx::astype(operands[0], mx::float32).item<float>(),
+                           mx::astype(operands[1], mx::float32)
+                               .item<float>())});
+            return WalkResult::advance();
+          })
+          // .Case<stablehlo::RngBitGeneratorOp>([](auto op) {})
+
+          // Handle StableHLO Quantize ops
+          // .Case<stablehlo::UniformQuantizeOp>([](auto op) {})
+          // .Case<stablehlo::UniformDequantizeOp>([](auto op) {})
+          // .Case<stablehlo::ReducePrecisionOp>([](auto op) {})
+          /*
+            .Case<stablehlo::RealDynamicSliceOp>([](auto op) {})
+            Deprecated see:
+              https://github.com/openxla/stablehlo/issues/2340
+              https://github.com/openxla/stablehlo/pull/2283
+          */
+          // .Case<stablehlo::DynamicPadOp>([](auto op) {})
+          // .Case<stablehlo::DynamicGatherOp>([](auto op) {})
+          // .Case<stablehlo::DynamicConvOp>([](auto op) {})
+          // .Case<stablehlo::DynamicGatherOp>([](auto op) {})
+
+          .Default([](auto op) {
+            // unhandled op, interrupt walk
+            return WalkResult::interrupt();
+          });
+    });
+
+    // TODO(@cryptodeal): ensure the resulting data is allocated/freed
+    // correctly.
+    if (res.has_value()) {
+      mx::array out = res.value();
+      mx::eval(out);
+      ArrayRef<float> data(out.data<float>(), out.size());
+      auto rank = out.ndim();
+      if (rank == 0) {
+        return SmallVector<DenseElementsAttr>{DenseElementsAttr::get<float>(
+            RankedTensorType::get({}, FloatType::getF32(module.getContext())),
+            data)};
+      }
+      auto out_shape = out.shape();
+      SmallVector<int64_t> shape;
+      for (auto dim : out_shape) {
+        shape.push_back(static_cast<int64_t>(dim));
+      }
+      DenseElementsAttr result = DenseElementsAttr::get(
+          RankedTensorType::get(ArrayRef<int64_t>(shape),
+                                FloatType::getF32(module.getContext())),
+          data);
+      return SmallVector<DenseElementsAttr>{result};
+    }
+    return failure();
+  }
+
+  absl::StatusOr<PjRtLoadedExecutable::Result> ExecuteWithMlxInterpreter(
+      absl::Span<PjRtBuffer* const> argument_handles, ModuleOp module,
+      PjRtDevice* device, bool fill_future) {
+    // TRACE_ME_MEMBER;
+    SmallVector<DenseElementsAttr> inputs;
+    for (auto* arg : argument_handles) {
+      TF_ASSIGN_OR_RETURN(auto mlirArg, GetAttributeFromBuffer(arg));
+      auto mlirArgInModuleContext =
+          CloneIntoContext(mlirArg, *module->getContext());
+      inputs.push_back(mlirArgInModuleContext);
+    }
+    // LOG(INFO) << "EvalModule:\n" << ToString(module) << "\n";
+    // LOG(INFO) << "Inputs: " << ToString(inputs) << "\n";
+    FailureOr<SmallVector<DenseElementsAttr>> result =
+        evalModule(module, inputs);
+    if (failed(result)) {
+      return absl::InternalError("Failed to execute module");
+    }
+    // LOG(INFO) << "Results: " << ToString(result.value()) << "\n";
+
+    // Naive memory space selection, only using CPU global memory.
+    PjRtMemorySpace* memory_space =
+        device->default_memory_space().value_or(nullptr);
+    std::vector<std::unique_ptr<PjRtBuffer>> buffer_results;
+    for (auto res : result.value()) {
+      buffer_results.push_back(
+          CreateMlirBufferFromAttribute(res, memory_space));
+    }
+
+    std::optional<PjRtFuture<>> future;
+    if (fill_future) {
+      // Synchronous! To make async, this would need to return a future that is
+      // ready when the computation is done.
+      future = PjRtFuture<>(absl::OkStatus());
+    }
+    return PjRtLoadedExecutable::Result{future, std::move(buffer_results)};
+  }
+
+  absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(
+      absl::Span<const std::vector<PjRtBuffer*>> argument_handles,
+      const xla::ExecuteOptions& options,
+      std::optional<std::vector<PjRtFuture<>>>& returned_futures) override {
+    // TRACE_ME_MEMBER;
+    if (argument_handles.size() != 1) {
+      // One arg handle per device.
+      return absl::InvalidArgumentError(
+          "MlirLoadedExecutable::Execute only supports a single argument "
+          "vector");
+    }
+
+    // Single device, synchronous, can always use 0.
+    PjRtDevice* device = devices_[0];
+    bool fill_future = returned_futures.has_value();
+    TF_ASSIGN_OR_RETURN(
+        PjRtLoadedExecutable::Result result,
+        ExecuteWithMlxInterpreter(argument_handles[0], module_.get(), device,
+                                  fill_future));
+    std::vector<std::vector<std::unique_ptr<PjRtBuffer>>> results;
+    results.push_back(std::move(result.buffers));
+    if (returned_futures.has_value()) {
+      returned_futures->push_back(std::move(result.future.value()));
+    }
+    return results;
+  }
+
+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(
+      absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,
+      const xla::ExecuteOptions& options,
+      std::optional<PjRtFuture<>>& returned_future, bool fill_future) override {
+    // TRACE_ME_MEMBER;
+    // Synchronous! To make async, have the device make a buffer with a ready
+    // future that is ready when the computation is done / buffer is ready.
+    TF_ASSIGN_OR_RETURN(
+        PjRtLoadedExecutable::Result result,
+        ExecuteWithMlxInterpreter(argument_handles, module_.get(), device,
+                                  fill_future));
+    if (returned_future.has_value() && fill_future) {
+      returned_future = std::move(result.future);
+    }
+    return std::move(result.buffers);
+  }
+
+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(
+      absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,
+      const xla::ExecuteOptions& options,
+      std::optional<PjRtFuture<>>& returned_future, bool fill_future) override {
+    // TRACE_ME_MEMBER;
+    // Synchronous! To make async, have the device make a buffer with a ready
+    // future that is ready when the computation is done / buffer is ready.
+    TF_ASSIGN_OR_RETURN(
+        PjRtLoadedExecutable::Result result,
+        ExecuteWithMlxInterpreter(argument_handles, module_.get(), device,
+                                  fill_future));
+    if (returned_future.has_value() && fill_future) {
+      returned_future = std::move(result.future);
+    }
+    return std::move(result.buffers);
+  }
+
+  void Delete() override {
+    // TRACE_ME_MEMBER;
+    module_.release();
+    module_ = nullptr;
+  }
+  bool IsDeleted() override {
+    // TRACE_ME_MEMBER;
+    return !module_;
+  }
+
+  // PjRtExecutable API.
+  int num_replicas() const override {
+    // TRACE_ME_MEMBER;
+    return assignment_.replica_count();
+  }
+  int num_partitions() const override {
+    // TRACE_ME_MEMBER;
+    return assignment_.computation_count();
+  }
+  int64_t SizeOfGeneratedCodeInBytes() const override {
+    // No generated code.. so just return 1.
+    // TRACE_ME_MEMBER;
+    return 1;
+  }
+  absl::string_view name() const override {
+    // TRACE_ME_MEMBER;
+    return name_;
+  }
+
+  absl::StatusOr<std::vector<std::shared_ptr<xla::HloModule>>> GetHloModules()
+      const override {
+    // TODO: This shouldn't be needed for an MLIR plugin, its only used in the
+    // JAX layer for determining output sharding, which exists on the mlir
+    // module.
+    // TRACE_ME_MEMBER;
+    auto moduleClone = llvm::cast<ModuleOp>(module_.get()->clone());
+    TF_ASSIGN_OR_RETURN(auto hlo_module,
+                        xla::ConvertStablehloToHlo(moduleClone));
+    return std::vector<std::shared_ptr<xla::HloModule>>{std::move(hlo_module)};
+  }
+
+  absl::StatusOr<std::vector<std::vector<absl::string_view>>>
+  GetOutputMemoryKinds() const override {
+    // TRACE_ME_MEMBER;
+    return UNIMPLEMENTED(GetOutputMemoryKinds);
+  }
+
+  absl::StatusOr<std::string> FingerprintExecutable() const override {
+    // TRACE_ME_MEMBER;
+    return UNIMPLEMENTED(FingerprintExecutable);
+  }
+
+ private:
+  std::string name_;
+  DeviceAssignment assignment_;
+  absl::Span<PjRtDevice* const> devices_;
+  PjRtClient* client_;
+
+  // MLIR
+  MLIRContext context_;
+  mlir::OwningOpRef<ModuleOp> module_;
+};
+
+absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> StablehloMlxCompile(
+    mlir::ModuleOp module, DeviceAssignment assignment, PjRtClient* client) {
+  TRACE_ME;
+  return MlirLoadedExecutable::Compile(module, assignment, client->devices(),
+                                       client);
+}
+
+absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> StablehloMlxCompile(
+    xla::XlaComputation const& computation, xla::DeviceAssignment assignment,
+    xla::PjRtClient* client) {
+  TRACE_ME;
+  MLIRContext context;
+  TF_ASSIGN_OR_RETURN(auto module,
+                      ConvertHloToStablehlo(context, &computation.proto()));
+  return StablehloMlxCompile(module.get(), assignment, client);
+}
+
+}  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/executable.h b/xla/pjrt/plugin/mlx/executable.h
new file mode 100644
index 0000000000..8c042c2206
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/executable.h
@@ -0,0 +1,35 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_EXECUTABLE_H_
+#define XLA_PJRT_PLUGIN_STABLEHLO_MLX_EXECUTABLE_H_
+
+#include <memory>
+
+#include "mlir/IR/BuiltinOps.h"
+#include "xla/hlo/builder/xla_computation.h"
+#include "xla/pjrt/pjrt_client.h"
+#include "xla/service/computation_placer.h"
+
+namespace mlir::stablehlo {
+
+absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> StablehloMlxCompile(
+    mlir::ModuleOp module, xla::DeviceAssignment assignment,
+    xla::PjRtClient* client);
+
+absl::StatusOr<std::unique_ptr<xla::PjRtLoadedExecutable>> StablehloMlxCompile(
+    xla::XlaComputation const& computation, xla::DeviceAssignment assignment,
+    xla::PjRtClient* client);
+
+}  // namespace mlir::stablehlo
+
+#endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_EXECUTABLE_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/logging.cc b/xla/pjrt/plugin/mlx/logging.cc
new file mode 100644
index 0000000000..f64ff19ec1
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/logging.cc
@@ -0,0 +1,69 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "xla/pjrt/plugin/mlx/logging.h"
+
+#include <cstdlib>
+
+#include "absl/base/log_severity.h"
+#include "absl/log/globals.h"
+#include "llvm/Support/raw_ostream.h"
+#include "mlir/IR/Attributes.h"
+#include "mlir/IR/BuiltinAttributes.h"
+#include "mlir/IR/Operation.h"
+
+namespace mlir::stablehlo {
+
+std::string ToString(mlir::Attribute attr) {
+  std::string out;
+  llvm::raw_string_ostream os(out);
+  attr.print(os);
+  return out;
+}
+
+std::string ToString(SmallVector<DenseElementsAttr> attrs) {
+  std::string out;
+  llvm::raw_string_ostream os(out);
+  os << "[";
+  bool first = true;
+  for (auto attr : attrs) {
+    if (!first) os << ", ";
+    first = false;
+    attr.print(os);
+  }
+  os << "]";
+  return out;
+}
+
+std::string ToString(Operation* op) {
+  std::string out;
+  llvm::raw_string_ostream os(out);
+  os << *op;
+  return out;
+}
+
+void SetupLogLevelFromEnv() {
+  absl::SetMinLogLevel(absl::LogSeverityAtLeast::kError);
+  const char* log_env = std::getenv("PJRT_LOG_LEVEL");
+  if (!log_env) return;
+  if (strcmp(log_env, "INFO") == 0) {
+    absl::SetMinLogLevel(absl::LogSeverityAtLeast::kInfo);
+  } else if (strcmp(log_env, "WARNING") == 0) {
+    absl::SetMinLogLevel(absl::LogSeverityAtLeast::kWarning);
+  } else if (strcmp(log_env, "ERROR") == 0) {
+    absl::SetMinLogLevel(absl::LogSeverityAtLeast::kError);
+  } else {
+    LOG(ERROR) << "Invalid PJRT_LOG_LEVEL: " << log_env;
+  }
+}
+
+}  // namespace mlir::stablehlo
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/logging.h b/xla/pjrt/plugin/mlx/logging.h
new file mode 100644
index 0000000000..f882c059d6
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/logging.h
@@ -0,0 +1,39 @@
+/* Copyright 2024 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef XLA_PJRT_PLUGIN_STABLEHLO_MLX_LOGGING_H_
+#define XLA_PJRT_PLUGIN_STABLEHLO_MLX_LOGGING_H_
+
+// This file has some joint logging to allow LOG and VLOG to play well with
+// MLIR data structures
+
+#include "absl/log/log.h"
+#include "mlir/IR/Attributes.h"
+#include "mlir/IR/BuiltinAttributes.h"
+
+#define LOG_UNIMPLEMENTED(name) \
+  LOG(ERROR) << "MlirPjrtBuffer::" #name " is not implemented"
+
+#define TRACE_ME LOG(INFO) << __func__;
+
+#define TRACE_ME_MEMBER LOG(INFO) << __func__ << "(" << (void*)this << ")\n";
+
+namespace mlir::stablehlo {
+std::string ToString(mlir::Attribute attr);
+std::string ToString(llvm::SmallVector<mlir::DenseElementsAttr> attrs);
+std::string ToString(Operation* op);
+
+// Looks for `PJRT_LOG_LEVEL = INFO|WARNING|ERROR` in env variables.
+void SetupLogLevelFromEnv();
+}  // namespace mlir::stablehlo
+
+#endif  // XLA_PJRT_PLUGIN_STABLEHLO_MLX_LOGGING_H_
\ No newline at end of file
diff --git a/xla/pjrt/plugin/mlx/plugin_pjrt_test.cc b/xla/pjrt/plugin/mlx/plugin_pjrt_test.cc
new file mode 100644
index 0000000000..d56a22565f
--- /dev/null
+++ b/xla/pjrt/plugin/mlx/plugin_pjrt_test.cc
@@ -0,0 +1,33 @@
+/* Copyright 2022 The OpenXLA Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#include "xla/pjrt/c/pjrt_c_api_test.h"
+#include "xla/pjrt/c/pjrt_c_api_wrapper_impl.h"
+#include "xla/pjrt/pjrt_client_test.h"
+#include "xla/pjrt/plugin/mlx/client_c_pjrt.h"
+#include "xla/pjrt/plugin/mlx/client_cpp_pjrt.h"
+
+namespace pjrt {
+namespace {
+
+const bool kUnused =
+    (RegisterPjRtCApiTestFactory([]() { return GetPjrtApi(); },
+                                 /*platform_name=*/"stablehlo_mlx"),
+     true);
+
+const bool kUnused2 = (xla::RegisterTestClientFactory([]() {
+                         return mlir::stablehlo::CreateStablehloMlxPjrtClient();
+                       }),
+                       true);
+
+}  // namespace
+}  // namespace pjrt
\ No newline at end of file
